<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Global</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Global</h1>

    



<section>

<header>
    <h2>
    
    </h2>
    
</header>

<article>
    <div class="container-overview">
    

    
        

        
<dl class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>


        
    
    </div>

    

    

    

    

    

    
        <h3 class="subsection-title">Members</h3>

        <dl>
            
<dt>
    <h4 class="name" id="$animate"><span class="type-signature"></span>$animate<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The $animate service provides rudimentary DOM manipulation functions to
insert, remove and move elements within the DOM, as well as adding and removing classes.
This service is the core service used by the ngAnimate $animator service which provides
high-level animation hooks for CSS and JavaScript.

$animate is available in the AngularJS core, however, the ngAnimate module must be included
to enable full out animation support. Otherwise, $animate will only perform simple DOM
manipulation operations.

To learn more about enabling animation support, click here to visit the ngAnimate module page as well as the {@link ngAnimate.$animate ngAnimate $animate service
page}.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line3965">line 3965</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$animateProvider"><span class="type-signature"></span>$animateProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Default implementation of $animate that doesn't perform any animations, instead just
synchronously performs DOM
updates and calls done() callbacks.

In order to enable animations the ngAnimate module has to be loaded.

To see the functional implementation check out src/ngAnimate/animate.js
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line3884">line 3884</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$browser"><span class="type-signature"></span>$browser<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        This object has two goals:

- hide all the global state in the browser caused by the window object
- abstract away all the browser specific features and inconsistencies

For tests we provide mock implementation of the `$browser`
service, which can be used for convenient testing of the application without the interaction with
the real browser apis.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line4124">line 4124</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$cacheFactory"><span class="type-signature"></span>$cacheFactory<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Factory that constructs cache objects and gives access to them.

```js

 var cache = $cacheFactory('cacheId');
 expect($cacheFactory.get('cacheId')).toBe(cache);
 expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();

 cache.put("key", "value");
 cache.put("another key", "another value");

 // We've specified no options on creation
 expect(cache.info()).toEqual({id: 'cacheId', size: 2});

```
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line4507">line 4507</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$controller"><span class="type-signature"></span>$controller<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        `$controller` service is responsible for instantiating controllers.

It's just a simple call to $injector, but extracted into
a service, so that one can override this service with [BC version](https://gist.github.com/1649788).
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line6818">line 6818</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$controllerProvider"><span class="type-signature"></span>$controllerProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The $controller service is used by Angular to create new
controllers.

This provider allows controller registration via the
register method.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line6783">line 6783</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$document"><span class="type-signature"></span>$document<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        A jQuery or jqLite wrapper for the browser's `window.document` object.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line6871">line 6871</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$exceptionHandler"><span class="type-signature"></span>$exceptionHandler<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Any uncaught exception in angular expressions is delegated to this service.
The default implementation simply delegates to `$log.error` which logs it into
the browser console.

In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
mock $exceptionHandler which aids in testing.

## Example:

```js
  angular.module('exceptionOverride', []).factory('$exceptionHandler', function () {
    return function (exception, cause) {
      exception.message += ' (caused by "' + cause + '")';
      throw exception;
    };
  });
```

This example will override the normal action of `$exceptionHandler`, to make angular
exceptions fail hard when they happen, instead of just logging to the console.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line6885">line 6885</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$filterProvider"><span class="type-signature"></span>$filterProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Filters are just functions which transform input to an output. However filters need to be
Dependency Injected. To achieve this a filter definition consists of a factory function which is
annotated with dependencies and is responsible for creating a filter function.

```js
  // Filter registration
  function MyModule($provide, $filterProvider) {
    // create a service to demonstrate injection (not always needed)
    $provide.value('greet', function(name){
      return 'Hello ' + name + '!';
    });

    // register a filter factory which uses the
    // greet service to demonstrate DI.
    $filterProvider.register('greet', function(greet){
      // return the filter function which uses the greet service
      // to generate salutation
      return function(text) {
        // filters need to be forgiving so check input validity
        return text && greet(text) || text;
      };
    });
  }
```

The filter function is registered with the `$injector` under the filter name suffix with
`Filter`.

```js
  it('should be the same instance', inject(
    function($filterProvider) {
      $filterProvider.register('reverse', function(){
        return ...;
      });
    },
    function($filter, reverseFilter) {
      expect($filter('reverse')).toBe(reverseFilter);
    });
```


For more information about how angular filters work, and how to create your own filters, see
Filters in the Angular Developer Guide.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line13805">line 13805</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$httpBackend"><span class="type-signature"></span>$httpBackend<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        HTTP backend used by the service that delegates to
XMLHttpRequest object or JSONP and deals with browser incompatibilities.

You should never need to use this service directly, instead use the higher-level abstractions:
$http or {@link ngResource.$resource $resource}.

During testing this implementation is swapped with mock $httpBackend which can be trained with responses.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line7971">line 7971</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$interval"><span class="type-signature"></span>$interval<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
milliseconds.

The return value of registering an interval function is a promise. This promise will be
notified upon each tick of the interval, and will be resolved after `count` iterations, or
run indefinitely if `count` is not defined. The value of the notification will be the
number of iterations that have run.
To cancel an interval, call `$interval.cancel(promise)`.

In tests you can use `$interval.flush(millis)` to
move forward by `millis` milliseconds and trigger any functions scheduled to run in that
time.

<div class="alert alert-warning">
**Note**: Intervals created by this service must be explicitly destroyed when you are finished
with them.  In particular they are not automatically destroyed when a controller's scope or a
directive's element are destroyed.
You should take this into consideration and make sure to always cancel the interval at the
appropriate moment.  See the example below for more details on how and when to do this.
</div>
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line8386">line 8386</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="time">
  &lt;file name="index.html">
    &lt;script>
      function Ctrl2($scope,$interval) {
        $scope.format = 'M/d/yy h:mm:ss a';
        $scope.blood_1 = 100;
        $scope.blood_2 = 120;

        var stop;
        $scope.fight = function() {
          // Don't start a new fight if we are already fighting
          if ( angular.isDefined(stop) ) return;

          stop = $interval(function() {
            if ($scope.blood_1 > 0 &amp;&amp; $scope.blood_2 > 0) {
                $scope.blood_1 = $scope.blood_1 - 3;
                $scope.blood_2 = $scope.blood_2 - 4;
            } else {
                $scope.stopFight();
            }
          }, 100);
        };

        $scope.stopFight = function() {
          if (angular.isDefined(stop)) {
            $interval.cancel(stop);
            stop = undefined;
          }
        };

        $scope.resetFight = function() {
          $scope.blood_1 = 100;
          $scope.blood_2 = 120;
        }

        $scope.$on('$destroy', function() {
          // Make sure that the interval is destroyed too
          $scope.stopFight();
        });
      }

      angular.module('time', [])
        // Register the 'myCurrentTime' directive factory method.
        // We inject $interval and dateFilter service since the factory method is DI.
        .directive('myCurrentTime', function($interval, dateFilter) {
          // return the directive link function. (compile function not needed)
          return function(scope, element, attrs) {
            var format,  // date format
            stopTime; // so that we can cancel the time updates

            // used to update the UI
            function updateTime() {
              element.text(dateFilter(new Date(), format));
            }

            // watch the expression, and update the UI on change.
            scope.$watch(attrs.myCurrentTime, function(value) {
              format = value;
              updateTime();
            });

            stopTime = $interval(updateTime, 1000);

            // listen on DOM destroy (removal) event, and cancel the next UI update
            // to prevent updating time ofter the DOM element was removed.
            element.bind('$destroy', function() {
              $interval.cancel(stopTime);
            });
          }
        });
    &lt;/script>

    &lt;div>
      &lt;div ng-controller="Ctrl2">
        Date format: &lt;input ng-model="format"> &lt;hr/>
        Current time is: &lt;span my-current-time="format">&lt;/span>
        &lt;hr/>
        Blood 1 : &lt;font color='red'>{{blood_1}}&lt;/font>
        Blood 2 : &lt;font color='red'>{{blood_2}}&lt;/font>
        &lt;button type="button" data-ng-click="fight()">Fight&lt;/button>
        &lt;button type="button" data-ng-click="stopFight()">StopFight&lt;/button>
        &lt;button type="button" data-ng-click="resetFight()">resetFight&lt;/button>
      &lt;/div>
    &lt;/div>

  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="$locale"><span class="type-signature"></span>$locale<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        $locale service provides localization rules for various Angular components. As of right now the
only public api is:

* `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line8564">line 8564</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$location"><span class="type-signature"></span>$location<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The $location service parses the URL in the browser address bar (based on the
[window.location](https://developer.mozilla.org/en/window.location)) and makes the URL
available to your application. Changes to the URL in the address bar are reflected into
$location service and changes to $location are reflected into the browser address bar.

**The $location service:**

- Exposes the current URL in the browser address bar, so you can
  - Watch and observe the URL.
  - Change the URL.
- Synchronizes the URL with the browser when the user
  - Changes the address bar.
  - Clicks the back or forward button (or clicks a History link).
  - Clicks on a link.
- Represents the URL object as a set of methods (protocol, host, port, path, search, hash).

For more information see Developer Guide: Angular Services: Using $location
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line9121">line 9121</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$locationProvider"><span class="type-signature"></span>$locationProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Use the `$locationProvider` to configure how the application deep linking paths are stored.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line9148">line 9148</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$log"><span class="type-signature"></span>$log<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Simple service for logging. Default implementation safely writes the message
into the browser's console (if present).

The main purpose of this service is to simplify debugging and troubleshooting.

The default is to log `debug` messages. You can use
ng.$logProvider#debugEnabled to change this.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line9327">line 9327</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="script.js">
    function LogCtrl($scope, $log) {
      $scope.$log = $log;
      $scope.message = 'Hello World!';
    }
  &lt;/file>
  &lt;file name="index.html">
    &lt;div ng-controller="LogCtrl">
      &lt;p>Reload this page with open console, enter text and hit the log button...&lt;/p>
      Message:
      &lt;input type="text" ng-model="message"/>
      &lt;button ng-click="$log.log(message)">log&lt;/button>
      &lt;button ng-click="$log.warn(message)">warn&lt;/button>
      &lt;button ng-click="$log.info(message)">info&lt;/button>
      &lt;button ng-click="$log.error(message)">error&lt;/button>
    &lt;/div>
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="$logProvider"><span class="type-signature"></span>$logProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Use the `$logProvider` to configure how the application logs messages
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line9363">line 9363</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$provide"><span class="type-signature"></span>$provide<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The $provide service has a number of methods for registering components
with the $injector. Many of these functions are also exposed on
angular.Module.

An Angular **service** is a singleton object created by a **service factory**.  These **service
factories** are functions which, in turn, are created by a **service provider**.
The **service providers** are constructor functions. When instantiated they must contain a
property called `$get`, which holds the **service factory** function.

When you request a service, the $injector is responsible for finding the
correct **service provider**, instantiating it and then calling its `$get` **service factory**
function to get the instance of the **service**.

Often services have no configuration options and there is no need to add methods to the service
provider.  The provider will be no more than a constructor function with a `$get` property. For
these cases the $provide service has additional helper methods to register
services without specifying a provider.

* provider(provider) - registers a **service provider** with the
    $injector
* {@link auto.$provide#methods_constant constant(obj)} - registers a value/object that can be accessed by
    providers and services.
* value(obj) - registers a value/object that can only be accessed by
    services, not providers.
* factory(fn) - registers a service **factory function**, `fn`,
    that will be wrapped in a **service provider** object, whose `$get` property will contain the
    given factory function.
* service(class) - registers a **constructor function**, `class` that
    that will be wrapped in a **service provider** object, whose `$get` property will instantiate
     a new object using the given constructor function.

See the individual methods for more information and examples.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line3269">line 3269</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$q"><span class="type-signature"></span>$q<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).

[The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
interface for interacting with an object that represents the result of an action that is
performed asynchronously, and may or may not be finished at any given point in time.

From the perspective of dealing with error handling, deferred and promise APIs are to
asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.

```js
  // for the purpose of this example let's assume that variables `$q`, `scope` and `okToGreet`
  // are available in the current lexical scope (they could have been injected or passed in).

  function asyncGreet(name) {
    var deferred = $q.defer();

    setTimeout(function() {
      // since this fn executes async in a future turn of the event loop, we need to wrap
      // our code into an $apply call so that the model changes are properly observed.
      scope.$apply(function() {
        deferred.notify('About to greet ' + name + '.');

        if (okToGreet(name)) {
          deferred.resolve('Hello, ' + name + '!');
        } else {
          deferred.reject('Greeting ' + name + ' is not allowed.');
        }
      });
    }, 1000);

    return deferred.promise;
  }

  var promise = asyncGreet('Robin Hood');
  promise.then(function(greeting) {
    alert('Success: ' + greeting);
  }, function(reason) {
    alert('Failed: ' + reason);
  }, function(update) {
    alert('Got notification: ' + update);
  });
```

At first it might not be obvious why this extra complexity is worth the trouble. The payoff
comes in the way of guarantees that promise and deferred APIs make, see
https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.

Additionally the promise api allows for composition that is very hard to do with the
traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
section on serial or parallel joining of promises.


# The Deferred API

A new instance of deferred is constructed by calling `$q.defer()`.

The purpose of the deferred object is to expose the associated Promise instance as well as APIs
that can be used for signaling the successful or unsuccessful completion, as well as the status
of the task.

**Methods**

- `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection
  constructed via `$q.reject`, the promise will be rejected instead.
- `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to
  resolving it with a rejection constructed via `$q.reject`.
- `notify(value)` - provides updates on the status of the promise's execution. This may be called
  multiple times before the promise is either resolved or rejected.

**Properties**

- promise – `{Promise}` – promise object associated with this deferred.


# The Promise API

A new promise instance is created when a deferred instance is created and can be retrieved by
calling `deferred.promise`.

The purpose of the promise object is to allow for interested parties to get access to the result
of the deferred task when it completes.

**Methods**

- `then(successCallback, errorCallback, notifyCallback)` – regardless of when the promise was or
  will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
  as soon as the result is available. The callbacks are called with a single argument: the result
  or rejection reason. Additionally, the notify callback may be called zero or more times to
  provide a progress indication, before the promise is resolved or rejected.

  This method *returns a new promise* which is resolved or rejected via the return value of the
  `successCallback`, `errorCallback`. It also notifies via the return value of the
  `notifyCallback` method. The promise can not be resolved or rejected from the notifyCallback
  method.

- `catch(errorCallback)` – shorthand for `promise.then(null, errorCallback)`

- `finally(callback)` – allows you to observe either the fulfillment or rejection of a promise,
  but to do so without modifying the final value. This is useful to release resources or do some
  clean-up that needs to be done whether the promise was rejected or resolved. See the [full
  specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
  more information.

  Because `finally` is a reserved word in JavaScript and reserved keywords are not supported as
  property names by ES3, you'll need to invoke the method like `promise['finally'](callback)` to
  make your code IE8 compatible.

# Chaining promises

Because calling the `then` method of a promise returns a new derived promise, it is easily
possible to create a chain of promises:

```js
  promiseB = promiseA.then(function(result) {
    return result + 1;
  });

  // promiseB will be resolved immediately after promiseA is resolved and its value
  // will be the result of promiseA incremented by 1
```

It is possible to create chains of any length and since a promise can be resolved with another
promise (which will defer its resolution further), it is possible to pause/defer resolution of
the promises at any point in the chain. This makes it possible to implement powerful APIs like
$http's response interceptors.


# Differences between Kris Kowal's Q and $q

 There are two main differences:

- $q is integrated with the ng.$rootScope.Scope Scope model observation
  mechanism in angular, which means faster propagation of resolution or rejection into your
  models and avoiding unnecessary browser repaints, which would result in flickering UI.
- Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
  all the important functionality needed for common async tasks.

 # Testing

 ```js
   it('should simulate promise', inject(function($q, $rootScope) {
     var deferred = $q.defer();
     var promise = deferred.promise;
     var resolvedValue;

     promise.then(function(value) { resolvedValue = value; });
     expect(resolvedValue).toBeUndefined();

     // Simulate resolving of promise
     deferred.resolve(123);
     // Note that the 'then' function does not get called synchronously.
     // This is because we want the promise API to always be async, whether or not
     // it got called synchronously or asynchronously.
     expect(resolvedValue).toBeUndefined();

     // Propagate promise resolution to 'then' functions using $apply().
     $rootScope.$apply();
     expect(resolvedValue).toEqual(123);
   }));
 ```
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line10753">line 10753</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$rootScope"><span class="type-signature"></span>$rootScope<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Every application has a single root scope.
All other scopes are descendant scopes of the root scope. Scopes provide separation
between the model and the view, via a mechanism for watching the model for changes.
They also provide an event emission/broadcast and subscription facility. See the
developer guide on scopes.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line11333">line 11333</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$rootScopeProvider"><span class="type-signature"></span>$rootScopeProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Provider for the $rootScope service.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line11303">line 11303</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$sceDelegateProvider"><span class="type-signature"></span>$sceDelegateProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `$sceDelegateProvider` provider allows developers to configure the $sceDelegate service.  This allows one to get/set the whitelists and blacklists used to ensure
that the URLs used for sourcing Angular templates are safe.  Refer $sceDelegateProvider.resourceUrlWhitelist and
{@link ng.$sceDelegateProvider#methods_resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}

For the general details about this service in Angular, read the main page for Strict Contextual Escaping (SCE).

**Example**:  Consider the following case. <a name="example"></a>

- your app is hosted at url `http://myapp.example.com/`
- but some of your templates are hosted on other domains you control such as
  `http://srv01.assets.example.com/`,  `http://srv02.assets.example.com/`, etc.
- and you have an open redirect at `http://myapp.example.com/clickThru?...`.

Here is what a secure configuration for this scenario might look like:

<pre class="prettyprint">
   angular.module('myApp', []).config(function($sceDelegateProvider) {
     $sceDelegateProvider.resourceUrlWhitelist([
       // Allow same origin resource loads.
       'self',
       // Allow loading from our assets domain.  Notice the difference between * and **.
       'http://srv*.assets.example.com/**']);

     // The blacklist overrides the whitelist so the open redirect here is blocked.
     $sceDelegateProvider.resourceUrlBlacklist([
       'http://myapp.example.com/clickThru**']);
     });
</pre>
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line12516">line 12516</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$sceProvider"><span class="type-signature"></span>$sceProvider<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The $sceProvider provider allows developers to configure the $sce service.
-   enable/disable Strict Contextual Escaping (SCE) in a module
-   override the default implementation with a custom delegate

Read more about Strict Contextual Escaping (SCE).
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line12803">line 12803</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$sniffer"><span class="type-signature"></span>$sniffer<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        This is very simple implementation of testing browser's features.
    </div>
    

    

    
<dl class="details">
    

        <h5 class="subsection-title">Properties:</h5>

        <dl>

<table class="props">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>history</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            

            

            <td class="description last">Does the browser support html5 history api ?</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>hashchange</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            

            

            <td class="description last">Does the browser support hashchange event ?</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>transitions</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            

            

            <td class="description last">Does the browser support CSS transition events ?</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>animations</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            

            

            <td class="description last">Does the browser support CSS animation events ?</td>
        </tr>

    
    </tbody>
</table></dl>

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line13483">line 13483</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$templateCache"><span class="type-signature"></span>$templateCache<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The first time a template is used, it is loaded in the template cache for quick retrieval. You
can load templates directly into the cache in a `script` tag, or by consuming the
`$templateCache` service directly.

Adding via the `script` tag:
```html
<html ng-app>
<head>
<script type="text/ng-template" id="templateId.html">
  This is the content of the template
</script>
</head>
  ...
</html>
```

**Note:** the `script` tag containing the template does not need to be included in the `head` of
the document, but it must be below the `ng-app` definition.

Adding via the $templateCache service:

```js
var myApp = angular.module('myApp', []);
myApp.run(function($templateCache) {
  $templateCache.put('templateId.html', 'This is the content of the template');
});
```

To retrieve the template later, simply use it in your HTML:
```html
<div ng-include=" 'templateId.html' "></div>
```

or get it via Javascript:
```js
$templateCache.get('templateId.html')
```

See $cacheFactory.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line4698">line 4698</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$timeout"><span class="type-signature"></span>$timeout<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
block and delegates any exceptions to
$exceptionHandler service.

The return value of registering a timeout function is a promise, which will be resolved when
the timeout is reached and the timeout function is executed.

To cancel a timeout request, call `$timeout.cancel(promise)`.

In tests you can use `$timeout.flush()` to
synchronously flush the queue of deferred functions.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line13581">line 13581</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$window"><span class="type-signature"></span>$window<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        A reference to the browser's `window` object. While `window`
is globally available in JavaScript, it causes testability problems, because
it is a global variable. In angular we always refer to it through the
`$window` service, so it may be overridden, removed or mocked for testing.

Expressions, like the one defined for the `ngClick` directive in the example
below, are evaluated with respect to the current scope.  Therefore, there is
no risk of inadvertently coding in a dependency on a global value in such an
expression.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line13761">line 13761</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script>
      function Ctrl($scope, $window) {
        $scope.greeting = 'Hello, World!';
        $scope.doGreeting = function(greeting) {
            $window.alert(greeting);
        };
      }
    &lt;/script>
    &lt;div ng-controller="Ctrl">
      &lt;input type="text" ng-model="greeting" />
      &lt;button ng-click="doGreeting(greeting)">ALERT&lt;/button>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
   it('should display the greeting in the input box', function() {
    element(by.model('greeting')).sendKeys('Hello, E2E Tests');
    // If we click the button it will block the test runner
    // element(':button').click();
   });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="a"><span class="type-signature"></span>a<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Modifies the default behavior of the html A tag so that the default action is prevented when
the href attribute is empty.

This change permits the easy creation of action links with the `ngClick` directive
without changing the location or causing page reloads, e.g.:
`<a href="" ng-click="list.addItem()">Add Item</a>`
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14867">line 14867</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="angular"><span class="type-signature"></span>angular<span class="type-signature"></span></h4>

    
</dt>
<dd>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line244">line 244</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="auto"><span class="type-signature"></span>auto<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Implicit module which gets automatically added to each $injector.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line3038">line 3038</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="form"><span class="type-signature"></span>form<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Directive that instantiates
<a href="global.html#form#FormController">FormController</a>.

If the `name` attribute is specified, the form controller is published onto the current scope under
this name.

# Alias: `ngForm`

In Angular forms can be nested. This means that the outer form is valid when all of the child
forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so
Angular provides the `ngForm` directive which behaves identically to
`<form>` but can be nested.  This allows you to have nested forms, which is very useful when
using Angular validation directives in forms that are dynamically generated using the
`ngRepeat` directive. Since you cannot dynamically generate the `name`
attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an
`ngForm` directive and nest these in an outer `form` element.


# CSS classes
 - `ng-valid` is set if the form is valid.
 - `ng-invalid` is set if the form is invalid.
 - `ng-pristine` is set if the form is pristine.
 - `ng-dirty` is set if the form is dirty.


# Submitting a form and preventing the default action

Since the role of forms in client-side Angular applications is different than in classical
roundtrip apps, it is desirable for the browser not to translate the form submission into a full
page reload that sends the data to the server. Instead some javascript logic should be triggered
to handle the form submission in an application-specific way.

For this reason, Angular prevents the default action (form submission to the server) unless the
`<form>` element has an `action` attribute specified.

You can use one of the following two ways to specify what javascript method should be called when
a form is submitted:

- ngSubmit directive on the form element
- ngClick directive on the first
 button or input field of type submit (input[type=submit])

To prevent double execution of the handler, use only one of the ngSubmit
or ngClick directives.
This is because of the following form submission rules in the HTML specification:

- If a form has only one input field then hitting enter in this field triggers form submit
(`ngSubmit`)
- if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
doesn't trigger submit
- if a form has one or more input fields and one or more buttons or input[type=submit] then
hitting enter in any of the input fields will trigger the click handler on the *first* button or
input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15520">line 15520</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.userType = 'guest';
     }
   &lt;/script>
   &lt;form name="myForm" ng-controller="Ctrl">
     userType: &lt;input name="input" ng-model="userType" required>
     &lt;span class="error" ng-show="myForm.input.$error.required">Required!&lt;/span>&lt;br>
     &lt;tt>userType = {{userType}}&lt;/tt>&lt;br>
     &lt;tt>myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt>&lt;br>
     &lt;tt>myForm.input.$error = {{myForm.input.$error}}&lt;/tt>&lt;br>
     &lt;tt>myForm.$valid = {{myForm.$valid}}&lt;/tt>&lt;br>
     &lt;tt>myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt>&lt;br>
    &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should initialize to model', function() {
      var userType = element(by.binding('userType'));
      var valid = element(by.binding('myForm.input.$valid'));

      expect(userType.getText()).toContain('guest');
      expect(valid.getText()).toContain('true');
    });

    it('should be invalid if empty', function() {
      var userType = element(by.binding('userType'));
      var valid = element(by.binding('myForm.input.$valid'));
      var userInput = element(by.model('userType'));

      userInput.clear();
      userInput.sendKeys('');

      expect(userType.getText()).toEqual('userType =');
      expect(valid.getText()).toContain('false');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="input"><span class="type-signature"></span>input<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        HTML input element control with angular data-binding. Input control follows HTML5 input types
and polyfills the HTML5 validation behavior for older browsers.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line16400">line 16400</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="input-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.user = {name: 'guest', last: 'visitor'};
     }
   &lt;/script>
   &lt;div ng-controller="Ctrl">
     &lt;form name="myForm">
       User name: &lt;input type="text" name="userName" ng-model="user.name" required>
       &lt;span class="error" ng-show="myForm.userName.$error.required">
         Required!&lt;/span>&lt;br>
       Last name: &lt;input type="text" name="lastName" ng-model="user.last"
         ng-minlength="3" ng-maxlength="10">
       &lt;span class="error" ng-show="myForm.lastName.$error.minlength">
         Too short!&lt;/span>
       &lt;span class="error" ng-show="myForm.lastName.$error.maxlength">
         Too long!&lt;/span>&lt;br>
     &lt;/form>
     &lt;hr>
     &lt;tt>user = {{user}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.userName.$valid = {{myForm.userName.$valid}}&lt;/tt>&lt;br>
     &lt;tt>myForm.userName.$error = {{myForm.userName.$error}}&lt;/tt>&lt;br>
     &lt;tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}&lt;/tt>&lt;br>
     &lt;tt>myForm.lastName.$error = {{myForm.lastName.$error}}&lt;/tt>&lt;br>
     &lt;tt>myForm.$valid = {{myForm.$valid}}&lt;/tt>&lt;br>
     &lt;tt>myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt>&lt;br>
     &lt;tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}&lt;/tt>&lt;br>
     &lt;tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}&lt;/tt>&lt;br>
   &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var user = element(by.binding('{{user}}'));
    var userNameValid = element(by.binding('myForm.userName.$valid'));
    var lastNameValid = element(by.binding('myForm.lastName.$valid'));
    var lastNameError = element(by.binding('myForm.lastName.$error'));
    var formValid = element(by.binding('myForm.$valid'));
    var userNameInput = element(by.model('user.name'));
    var userLastInput = element(by.model('user.last'));

    it('should initialize to model', function() {
      expect(user.getText()).toContain('{"name":"guest","last":"visitor"}');
      expect(userNameValid.getText()).toContain('true');
      expect(formValid.getText()).toContain('true');
    });

    it('should be invalid if empty when required', function() {
      userNameInput.clear();
      userNameInput.sendKeys('');

      expect(user.getText()).toContain('{"last":"visitor"}');
      expect(userNameValid.getText()).toContain('false');
      expect(formValid.getText()).toContain('false');
    });

    it('should be valid if empty when min length is set', function() {
      userLastInput.clear();
      userLastInput.sendKeys('');

      expect(user.getText()).toContain('{"name":"guest","last":""}');
      expect(lastNameValid.getText()).toContain('true');
      expect(formValid.getText()).toContain('true');
    });

    it('should be invalid if less than required min length', function() {
      userLastInput.clear();
      userLastInput.sendKeys('xx');

      expect(user.getText()).toContain('{"name":"guest"}');
      expect(lastNameValid.getText()).toContain('false');
      expect(lastNameError.getText()).toContain('minlength');
      expect(formValid.getText()).toContain('false');
    });

    it('should be invalid if longer than max length', function() {
      userLastInput.clear();
      userLastInput.sendKeys('some ridiculously long name');

      expect(user.getText()).toContain('{"name":"guest"}');
      expect(lastNameValid.getText()).toContain('false');
      expect(lastNameError.getText()).toContain('maxlength');
      expect(formValid.getText()).toContain('false');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="input[checkbox]"><span class="type-signature"></span>input[checkbox]<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        HTML checkbox.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line16055">line 16055</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="checkbox-input-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.value1 = true;
       $scope.value2 = 'YES'
     }
   &lt;/script>
   &lt;form name="myForm" ng-controller="Ctrl">
     Value1: &lt;input type="checkbox" ng-model="value1"> &lt;br/>
     Value2: &lt;input type="checkbox" ng-model="value2"
                    ng-true-value="YES" ng-false-value="NO"> &lt;br/>
     &lt;tt>value1 = {{value1}}&lt;/tt>&lt;br/>
     &lt;tt>value2 = {{value2}}&lt;/tt>&lt;br/>
    &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should change state', function() {
      var value1 = element(by.binding('value1'));
      var value2 = element(by.binding('value2'));

      expect(value1.getText()).toContain('true');
      expect(value2.getText()).toContain('YES');

      element(by.model('value1')).click();
      element(by.model('value2')).click();

      expect(value1.getText()).toContain('false');
      expect(value2.getText()).toContain('NO');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="input[email]"><span class="type-signature"></span>input[email]<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Text input with email validation. Sets the `email` validation error key if not a valid email
address.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15929">line 15929</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="email-input-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.text = 'me@example.com';
     }
   &lt;/script>
     &lt;form name="myForm" ng-controller="Ctrl">
       Email: &lt;input type="email" name="input" ng-model="text" required>
       &lt;span class="error" ng-show="myForm.input.$error.required">
         Required!&lt;/span>
       &lt;span class="error" ng-show="myForm.input.$error.email">
         Not valid email!&lt;/span>
       &lt;tt>text = {{text}}&lt;/tt>&lt;br/>
       &lt;tt>myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt>&lt;br/>
       &lt;tt>myForm.input.$error = {{myForm.input.$error}}&lt;/tt>&lt;br/>
       &lt;tt>myForm.$valid = {{myForm.$valid}}&lt;/tt>&lt;br/>
       &lt;tt>myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt>&lt;br/>
       &lt;tt>myForm.$error.email = {{!!myForm.$error.email}}&lt;/tt>&lt;br/>
     &lt;/form>
   &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var text = element(by.binding('text'));
    var valid = element(by.binding('myForm.input.$valid'));
    var input = element(by.model('text'));

    it('should initialize to model', function() {
      expect(text.getText()).toContain('me@example.com');
      expect(valid.getText()).toContain('true');
    });

    it('should be invalid if empty', function() {
      input.clear();
      input.sendKeys('');
      expect(text.getText()).toEqual('text =');
      expect(valid.getText()).toContain('false');
    });

    it('should be invalid if not email', function() {
      input.clear();
      input.sendKeys('xxx');

      expect(valid.getText()).toContain('false');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="input[number]"><span class="type-signature"></span>input[number]<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Text input with number validation and transformation. Sets the `number` validation
error if not a valid number.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15776">line 15776</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="number-input-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.value = 12;
     }
   &lt;/script>
   &lt;form name="myForm" ng-controller="Ctrl">
     Number: &lt;input type="number" name="input" ng-model="value"
                    min="0" max="99" required>
     &lt;span class="error" ng-show="myForm.input.$error.required">
       Required!&lt;/span>
     &lt;span class="error" ng-show="myForm.input.$error.number">
       Not valid number!&lt;/span>
     &lt;tt>value = {{value}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.input.$error = {{myForm.input.$error}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$valid = {{myForm.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt>&lt;br/>
    &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var value = element(by.binding('value'));
    var valid = element(by.binding('myForm.input.$valid'));
    var input = element(by.model('value'));

    it('should initialize to model', function() {
      expect(value.getText()).toContain('12');
      expect(valid.getText()).toContain('true');
    });

    it('should be invalid if empty', function() {
      input.clear();
      input.sendKeys('');
      expect(value.getText()).toEqual('value =');
      expect(valid.getText()).toContain('false');
    });

    it('should be invalid if over max', function() {
      input.clear();
      input.sendKeys('123');
      expect(value.getText()).toEqual('value =');
      expect(valid.getText()).toContain('false');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="input[radio]"><span class="type-signature"></span>input[radio]<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        HTML radio button.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line16004">line 16004</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="radio-input-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.color = 'blue';
       $scope.specialValue = {
         "id": "12345",
         "value": "green"
       };
     }
   &lt;/script>
   &lt;form name="myForm" ng-controller="Ctrl">
     &lt;input type="radio" ng-model="color" value="red">  Red &lt;br/>
     &lt;input type="radio" ng-model="color" ng-value="specialValue"> Green &lt;br/>
     &lt;input type="radio" ng-model="color" value="blue"> Blue &lt;br/>
     &lt;tt>color = {{color | json}}&lt;/tt>&lt;br/>
    &lt;/form>
    Note that `ng-value="specialValue"` sets radio item's value to be the value of `$scope.specialValue`.
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should change state', function() {
      var color = element(by.binding('color'));

      expect(color.getText()).toContain('blue');

      element.all(by.model('color')).get(0).click();

      expect(color.getText()).toContain('red');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="input[text]"><span class="type-signature"></span>input[text]<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Standard HTML text input with angular data binding.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15698">line 15698</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="text-input-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.text = 'guest';
       $scope.word = /^\s*\w*\s*$/;
     }
   &lt;/script>
   &lt;form name="myForm" ng-controller="Ctrl">
     Single word: &lt;input type="text" name="input" ng-model="text"
                         ng-pattern="word" required ng-trim="false">
     &lt;span class="error" ng-show="myForm.input.$error.required">
       Required!&lt;/span>
     &lt;span class="error" ng-show="myForm.input.$error.pattern">
       Single word only!&lt;/span>

     &lt;tt>text = {{text}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.input.$error = {{myForm.input.$error}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$valid = {{myForm.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt>&lt;br/>
    &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var text = element(by.binding('text'));
    var valid = element(by.binding('myForm.input.$valid'));
    var input = element(by.model('text'));

    it('should initialize to model', function() {
      expect(text.getText()).toContain('guest');
      expect(valid.getText()).toContain('true');
    });

    it('should be invalid if empty', function() {
      input.clear();
      input.sendKeys('');

      expect(text.getText()).toEqual('text =');
      expect(valid.getText()).toContain('false');
    });

    it('should be invalid if multi word', function() {
      input.clear();
      input.sendKeys('hello world');

      expect(valid.getText()).toContain('false');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="input[url]"><span class="type-signature"></span>input[url]<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Text input with URL validation. Sets the `url` validation error key if the content is not a
valid URL.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15853">line 15853</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="url-input-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.text = 'http://google.com';
     }
   &lt;/script>
   &lt;form name="myForm" ng-controller="Ctrl">
     URL: &lt;input type="url" name="input" ng-model="text" required>
     &lt;span class="error" ng-show="myForm.input.$error.required">
       Required!&lt;/span>
     &lt;span class="error" ng-show="myForm.input.$error.url">
       Not valid url!&lt;/span>
     &lt;tt>text = {{text}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.input.$error = {{myForm.input.$error}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$valid = {{myForm.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$error.url = {{!!myForm.$error.url}}&lt;/tt>&lt;br/>
    &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var text = element(by.binding('text'));
    var valid = element(by.binding('myForm.input.$valid'));
    var input = element(by.model('text'));

    it('should initialize to model', function() {
      expect(text.getText()).toContain('http://google.com');
      expect(valid.getText()).toContain('true');
    });

    it('should be invalid if empty', function() {
      input.clear();
      input.sendKeys('');

      expect(text.getText()).toEqual('text =');
      expect(valid.getText()).toContain('false');
    });

    it('should be invalid if not url', function() {
      input.clear();
      input.sendKeys('box');

      expect(valid.getText()).toContain('false');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngBind"><span class="type-signature"></span>ngBind<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
with the value of a given expression, and to update the text content when the value of that
expression changes.

Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
`{{ expression }}` which is similar but less verbose.

It is preferrable to use `ngBind` instead of `{{ expression }}` when a template is momentarily
displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an
element attribute, it makes the bindings invisible to the user while the page is loading.

An alternative solution to this problem would be using the
ngCloak directive.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17188">line 17188</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
   &lt;example>
     &lt;file name="index.html">
       &lt;script>
         function Ctrl($scope) {
           $scope.name = 'Whirled';
         }
       &lt;/script>
       &lt;div ng-controller="Ctrl">
         Enter name: &lt;input type="text" ng-model="name">&lt;br>
         Hello &lt;span ng-bind="name">&lt;/span>!
       &lt;/div>
     &lt;/file>
     &lt;file name="protractor.js" type="protractor">
       it('should check ng-bind', function() {
         var nameInput = element(by.model('name'));

         expect(element(by.binding('name')).getText()).toBe('Whirled');
         nameInput.clear();
         nameInput.sendKeys('world');
         expect(element(by.binding('name')).getText()).toBe('world');
       });
     &lt;/file>
   &lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngBindHtml"><span class="type-signature"></span>ngBindHtml<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Creates a binding that will innerHTML the result of evaluating the `expression` into the current
element in a secure way.  By default, the innerHTML-ed content will be sanitized using the $sanitize service.  To utilize this functionality, ensure that `$sanitize`
is available, for example, by including ngSanitize in your module's dependencies (not in
core Angular.)  You may also bypass sanitization for values you know are safe. To do so, bind to
an explicitly trusted value via $sce.trustAsHtml.  See the example
under {@link ng.$sce#Example Strict Contextual Escaping (SCE)}.

Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you
will have an exception (instead of an exploit.)
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17311">line 17311</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>Try it here: enter text in text box and watch the greeting change.

&lt;example module="ngBindHtmlExample" deps="angular-sanitize.js">
  &lt;file name="index.html">
    &lt;div ng-controller="ngBindHtmlCtrl">
     &lt;p ng-bind-html="myHTML">&lt;/p>
    &lt;/div>
  &lt;/file>

  &lt;file name="script.js">
    angular.module('ngBindHtmlExample', ['ngSanitize'])

    .controller('ngBindHtmlCtrl', ['$scope', function ngBindHtmlCtrl($scope) {
      $scope.myHTML =
         'I am an &lt;code>HTML&lt;/code>string with &lt;a href="#">links!&lt;/a> and other &lt;em>stuff&lt;/em>';
    }]);
  &lt;/file>

  &lt;file name="protractor.js" type="protractor">
    it('should check ng-bind-html', function() {
      expect(element(by.binding('myHTML')).getText()).toBe(
          'I am an HTMLstring with links! and other stuff');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngBindTemplate"><span class="type-signature"></span>ngBindTemplate<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngBindTemplate` directive specifies that the element
text content should be replaced with the interpolation of the template
in the `ngBindTemplate` attribute.
Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`
expressions. This directive is needed since some HTML elements
(such as TITLE and OPTION) cannot contain SPAN elements.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17249">line 17249</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>Try it here: enter text in text box and watch the greeting change.
   &lt;example>
     &lt;file name="index.html">
       &lt;script>
         function Ctrl($scope) {
           $scope.salutation = 'Hello';
           $scope.name = 'World';
         }
       &lt;/script>
       &lt;div ng-controller="Ctrl">
        Salutation: &lt;input type="text" ng-model="salutation">&lt;br>
        Name: &lt;input type="text" ng-model="name">&lt;br>
        &lt;pre ng-bind-template="{{salutation}} {{name}}!">&lt;/pre>
       &lt;/div>
     &lt;/file>
     &lt;file name="protractor.js" type="protractor">
       it('should check ng-bind', function() {
         var salutationElem = element(by.binding('salutation'));
         var salutationInput = element(by.model('salutation'));
         var nameInput = element(by.model('name'));

         expect(salutationElem.getText()).toBe('Hello World!');

         salutationInput.clear();
         salutationInput.sendKeys('Greetings');
         nameInput.clear();
         nameInput.sendKeys('user');

         expect(salutationElem.getText()).toBe('Greetings user!');
       });
     &lt;/file>
   &lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngChange"><span class="type-signature"></span>ngChange<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Evaluate the given expression when the user changes the input.
The expression is evaluated immediately, unlike the JavaScript onchange event
which only triggers at the end of a change (usually, when the user leaves the
form element or presses the return key).
The expression is not evaluated when the value change is coming from the model.

Note, this directive requires `ngModel` to be present.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line16927">line 16927</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="ngChange-directive">
  &lt;file name="index.html">
    &lt;script>
      function Controller($scope) {
        $scope.counter = 0;
        $scope.change = function() {
          $scope.counter++;
        };
      }
    &lt;/script>
    &lt;div ng-controller="Controller">
      &lt;input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
      &lt;input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
      &lt;label for="ng-change-example2">Confirmed&lt;/label>&lt;br />
      &lt;tt>debug = {{confirmed}}&lt;/tt>&lt;br/>
      &lt;tt>counter = {{counter}}&lt;/tt>&lt;br/>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var counter = element(by.binding('counter'));
    var debug = element(by.binding('confirmed'));

    it('should evaluate the expression if changing from view', function() {
      expect(counter.getText()).toContain('0');

      element(by.id('ng-change-example1')).click();

      expect(counter.getText()).toContain('1');
      expect(debug.getText()).toContain('true');
    });

    it('should not evaluate the expression if changing from model', function() {
      element(by.id('ng-change-example2')).click();
      expect(counter.getText()).toContain('0');
      expect(debug.getText()).toContain('true');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngChecked"><span class="type-signature"></span>ngChecked<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The HTML specification does not require browsers to preserve the values of boolean attributes
such as checked. (Their presence means true and their absence means false.)
If we put an Angular interpolation expression into such an attribute then the
binding information would be lost when the browser removes the attribute.
The `ngChecked` directive solves this problem for the `checked` attribute.
This complementary directive is not removed by the browser and so provides
a permanent reliable place to store the binding information.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15111">line 15111</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    Check me to check both: &lt;input type="checkbox" ng-model="master">&lt;br/>
    &lt;input id="checkSlave" type="checkbox" ng-checked="master">
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should check both checkBoxes', function() {
      expect(element(by.id('checkSlave')).getAttribute('checked')).toBeFalsy();
      element(by.model('master')).click();
      expect(element(by.id('checkSlave')).getAttribute('checked')).toBeTruthy();
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngClass"><span class="type-signature"></span>ngClass<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngClass` directive allows you to dynamically set CSS classes on an HTML element by databinding
an expression that represents all classes to be added.

The directive operates in three different ways, depending on which of three types the expression
evaluates to:

1. If the expression evaluates to a string, the string should be one or more space-delimited class
names.

2. If the expression evaluates to an array, each element of the array should be a string that is
one or more space-delimited class names.

3. If the expression evaluates to an object, then for each key-value pair of the
object with a truthy value the corresponding key is used as a class name.

The directive won't add duplicate classes if a particular class was already set.

When the expression changes, the previously added classes are removed and only then the
new classes are added.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17432">line 17432</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>Example that demonstrates basic bindings via ngClass directive.
  &lt;example>
    &lt;file name="index.html">
      &lt;p ng-class="{strike: deleted, bold: important, red: error}">Map Syntax Example&lt;/p>
      &lt;input type="checkbox" ng-model="deleted"> deleted (apply "strike" class)&lt;br>
      &lt;input type="checkbox" ng-model="important"> important (apply "bold" class)&lt;br>
      &lt;input type="checkbox" ng-model="error"> error (apply "red" class)
      &lt;hr>
      &lt;p ng-class="style">Using String Syntax&lt;/p>
      &lt;input type="text" ng-model="style" placeholder="Type: bold strike red">
      &lt;hr>
      &lt;p ng-class="[style1, style2, style3]">Using Array Syntax&lt;/p>
      &lt;input ng-model="style1" placeholder="Type: bold, strike or red">&lt;br>
      &lt;input ng-model="style2" placeholder="Type: bold, strike or red">&lt;br>
      &lt;input ng-model="style3" placeholder="Type: bold, strike or red">&lt;br>
    &lt;/file>
    &lt;file name="style.css">
      .strike {
        text-decoration: line-through;
      }
      .bold {
          font-weight: bold;
      }
      .red {
          color: red;
      }
    &lt;/file>
    &lt;file name="protractor.js" type="protractor">
      var ps = element.all(by.css('p'));

      it('should let you toggle the class', function() {

        expect(ps.first().getAttribute('class')).not.toMatch(/bold/);
        expect(ps.first().getAttribute('class')).not.toMatch(/red/);

        element(by.model('important')).click();
        expect(ps.first().getAttribute('class')).toMatch(/bold/);

        element(by.model('error')).click();
        expect(ps.first().getAttribute('class')).toMatch(/red/);
      });

      it('should let you toggle string example', function() {
        expect(ps.get(1).getAttribute('class')).toBe('');
        element(by.model('style')).clear();
        element(by.model('style')).sendKeys('red');
        expect(ps.get(1).getAttribute('class')).toBe('red');
      });

      it('array example should have 3 classes', function() {
        expect(ps.last().getAttribute('class')).toBe('');
        element(by.model('style1')).sendKeys('bold');
        element(by.model('style2')).sendKeys('strike');
        element(by.model('style3')).sendKeys('red');
        expect(ps.last().getAttribute('class')).toBe('bold strike red');
      });
    &lt;/file>
  &lt;/example>

  ## Animations

  The example below demonstrates how to perform animations using ngClass.

  &lt;example module="ngAnimate" deps="angular-animate.js" animations="true">
    &lt;file name="index.html">
     &lt;input id="setbtn" type="button" value="set" ng-click="myVar='my-class'">
     &lt;input id="clearbtn" type="button" value="clear" ng-click="myVar=''">
     &lt;br>
     &lt;span class="base-class" ng-class="myVar">Sample Text&lt;/span>
    &lt;/file>
    &lt;file name="style.css">
      .base-class {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      }

      .base-class.my-class {
        color: red;
        font-size:3em;
      }
    &lt;/file>
    &lt;file name="protractor.js" type="protractor">
      it('should check ng-class', function() {
        expect(element(by.css('.base-class')).getAttribute('class')).not.
          toMatch(/my-class/);

        element(by.id('setbtn')).click();

        expect(element(by.css('.base-class')).getAttribute('class')).
          toMatch(/my-class/);

        element(by.id('clearbtn')).click();

        expect(element(by.css('.base-class')).getAttribute('class')).not.
          toMatch(/my-class/);
      });
    &lt;/file>
  &lt;/example>


  ## ngClass and pre-existing CSS3 Transitions/Animations
  The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.
  Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder
  any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure
  to view the step by step details of $animate.addClass and
  {@link ngAnimate.$animate#methods_removeclass $animate.removeClass}.</code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngClassEven"><span class="type-signature"></span>ngClassEven<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngClassOdd` and `ngClassEven` directives work exactly as
ngClass, except they work in
conjunction with `ngRepeat` and take effect only on odd (even) rows.

This directive can be applied only within the scope of an
ngRepeat.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17626">line 17626</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
     &lt;ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
       &lt;li ng-repeat="name in names">
        &lt;span ng-class-odd="'odd'" ng-class-even="'even'">
          {{name}} &amp;nbsp; &amp;nbsp; &amp;nbsp;
        &lt;/span>
       &lt;/li>
     &lt;/ol>
  &lt;/file>
  &lt;file name="style.css">
    .odd {
      color: red;
    }
    .even {
      color: blue;
    }
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should check ng-class-odd and ng-class-even', function() {
      expect(element(by.repeater('name in names').row(0).column('name')).getAttribute('class')).
        toMatch(/odd/);
      expect(element(by.repeater('name in names').row(1).column('name')).getAttribute('class')).
        toMatch(/even/);
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngClassOdd"><span class="type-signature"></span>ngClassOdd<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngClassOdd` and `ngClassEven` directives work exactly as
ngClass, except they work in
conjunction with `ngRepeat` and take effect only on odd (even) rows.

This directive can be applied only within the scope of an
ngRepeat.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17578">line 17578</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
     &lt;ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
       &lt;li ng-repeat="name in names">
        &lt;span ng-class-odd="'odd'" ng-class-even="'even'">
          {{name}}
        &lt;/span>
       &lt;/li>
     &lt;/ol>
  &lt;/file>
  &lt;file name="style.css">
    .odd {
      color: red;
    }
    .even {
      color: blue;
    }
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should check ng-class-odd and ng-class-even', function() {
      expect(element(by.repeater('name in names').row(0).column('name')).getAttribute('class')).
        toMatch(/odd/);
      expect(element(by.repeater('name in names').row(1).column('name')).getAttribute('class')).
        toMatch(/even/);
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngClick"><span class="type-signature"></span>ngClick<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The ngClick directive allows you to specify custom behavior when
an element is clicked.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17979">line 17979</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;button ng-click="count = count + 1" ng-init="count=0">
     Increment
   &lt;/button>
   count: {{count}}
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should check ng-click', function() {
      expect(element(by.binding('count')).getText()).toMatch('0');
      element(by.css('button')).click();
      expect(element(by.binding('count')).getText()).toMatch('1');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngCloak"><span class="type-signature"></span>ngCloak<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngCloak` directive is used to prevent the Angular html template from being briefly
displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
directive to avoid the undesirable flicker effect caused by the html template display.

The directive can be applied to the `<body>` element, but the preferred usage is to apply
multiple `ngCloak` directives to small portions of the page to permit progressive rendering
of the browser view.

`ngCloak` works in cooperation with the following css rule embedded within `angular.js` and
`angular.min.js`.
For CSP mode please add `angular-csp.css` to your html file (see ngCsp).

```css
[ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
  display: none !important;
}
```

When this css rule is loaded by the browser, all html elements (including their children) that
are tagged with the `ngCloak` directive are hidden. When Angular encounters this directive
during the compilation of the template it deletes the `ngCloak` element attribute, making
the compiled element visible.

For the best result, the `angular.js` script must be loaded in the head section of the html
document; alternatively, the css rule above must be included in the external stylesheet of the
application.

Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
class `ng-cloak` in addition to the `ngCloak` directive as shown in the example below.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17674">line 17674</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
     &lt;div id="template1" ng-cloak>{{ 'hello' }}&lt;/div>
     &lt;div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}&lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should remove the template directive and css class', function() {
      expect($('#template1').getAttribute('ng-cloak')).
        toBeNull();
      expect($('#template2').getAttribute('ng-cloak')).
        toBeNull();
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngController"><span class="type-signature"></span>ngController<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular
supports the principles behind the Model-View-Controller design pattern.

MVC components in angular:

* Model — The Model is scope properties; scopes are attached to the DOM where scope properties
  are accessed through bindings.
* View — The template (HTML with data bindings) that is rendered into the View.
* Controller — The `ngController` directive specifies a Controller class; the class contains business
  logic behind the application to decorate the scope with functions and values

Note that you can also attach controllers to the DOM by declaring it in a route definition
via the $route service. A common mistake is to declare the controller
again using `ng-controller` in the template itself.  This will cause the controller to be attached
and executed twice.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17737">line 17737</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>Here is a simple form for editing user contact information. Adding, removing, clearing, and
greeting are methods declared on the controller (see source tab). These methods can
easily be called from the angular markup. Notice that the scope becomes the `this` for the
controller's instance. This allows for easy access to the view data from the controller. Also
notice that any changes to the data are automatically reflected in the View without the need
for a manual update. The example is shown in two different declaration styles you may use
according to preference.
   &lt;example>
     &lt;file name="index.html">
      &lt;script>
        function SettingsController1() {
          this.name = "John Smith";
          this.contacts = [
            {type: 'phone', value: '408 555 1212'},
            {type: 'email', value: 'john.smith@example.org'} ];
          };

        SettingsController1.prototype.greet = function() {
          alert(this.name);
        };

        SettingsController1.prototype.addContact = function() {
          this.contacts.push({type: 'email', value: 'yourname@example.org'});
        };

        SettingsController1.prototype.removeContact = function(contactToRemove) {
         var index = this.contacts.indexOf(contactToRemove);
          this.contacts.splice(index, 1);
        };

        SettingsController1.prototype.clearContact = function(contact) {
          contact.type = 'phone';
          contact.value = '';
        };
      &lt;/script>
      &lt;div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
        Name: &lt;input type="text" ng-model="settings.name"/>
        [ &lt;a href="" ng-click="settings.greet()">greet&lt;/a> ]&lt;br/>
        Contact:
        &lt;ul>
          &lt;li ng-repeat="contact in settings.contacts">
            &lt;select ng-model="contact.type">
               &lt;option>phone&lt;/option>
               &lt;option>email&lt;/option>
            &lt;/select>
            &lt;input type="text" ng-model="contact.value"/>
            [ &lt;a href="" ng-click="settings.clearContact(contact)">clear&lt;/a>
            | &lt;a href="" ng-click="settings.removeContact(contact)">X&lt;/a> ]
          &lt;/li>
          &lt;li>[ &lt;a href="" ng-click="settings.addContact()">add&lt;/a> ]&lt;/li>
       &lt;/ul>
      &lt;/div>
     &lt;/file>
     &lt;file name="protractor.js" type="protractor">
       it('should check controller as', function() {
         var container = element(by.id('ctrl-as-exmpl'));

         expect(container.findElement(by.model('settings.name'))
             .getAttribute('value')).toBe('John Smith');

         var firstRepeat =
             container.findElement(by.repeater('contact in settings.contacts').row(0));
         var secondRepeat =
             container.findElement(by.repeater('contact in settings.contacts').row(1));

         expect(firstRepeat.findElement(by.model('contact.value')).getAttribute('value'))
             .toBe('408 555 1212');
         expect(secondRepeat.findElement(by.model('contact.value')).getAttribute('value'))
             .toBe('john.smith@example.org');

         firstRepeat.findElement(by.linkText('clear')).click();

         expect(firstRepeat.findElement(by.model('contact.value')).getAttribute('value'))
             .toBe('');

         container.findElement(by.linkText('add')).click();

         expect(container.findElement(by.repeater('contact in settings.contacts').row(2))
             .findElement(by.model('contact.value'))
             .getAttribute('value'))
             .toBe('yourname@example.org');
       });
     &lt;/file>
   &lt;/example>
    &lt;example>
     &lt;file name="index.html">
      &lt;script>
        function SettingsController2($scope) {
          $scope.name = "John Smith";
          $scope.contacts = [
            {type:'phone', value:'408 555 1212'},
            {type:'email', value:'john.smith@example.org'} ];

          $scope.greet = function() {
           alert(this.name);
          };

          $scope.addContact = function() {
           this.contacts.push({type:'email', value:'yourname@example.org'});
          };

          $scope.removeContact = function(contactToRemove) {
           var index = this.contacts.indexOf(contactToRemove);
           this.contacts.splice(index, 1);
          };

          $scope.clearContact = function(contact) {
           contact.type = 'phone';
           contact.value = '';
          };
        }
      &lt;/script>
      &lt;div id="ctrl-exmpl" ng-controller="SettingsController2">
        Name: &lt;input type="text" ng-model="name"/>
        [ &lt;a href="" ng-click="greet()">greet&lt;/a> ]&lt;br/>
        Contact:
        &lt;ul>
          &lt;li ng-repeat="contact in contacts">
            &lt;select ng-model="contact.type">
               &lt;option>phone&lt;/option>
               &lt;option>email&lt;/option>
            &lt;/select>
            &lt;input type="text" ng-model="contact.value"/>
            [ &lt;a href="" ng-click="clearContact(contact)">clear&lt;/a>
            | &lt;a href="" ng-click="removeContact(contact)">X&lt;/a> ]
          &lt;/li>
          &lt;li>[ &lt;a href="" ng-click="addContact()">add&lt;/a> ]&lt;/li>
       &lt;/ul>
      &lt;/div>
     &lt;/file>
     &lt;file name="protractor.js" type="protractor">
       it('should check controller', function() {
         var container = element(by.id('ctrl-exmpl'));

         expect(container.findElement(by.model('name'))
             .getAttribute('value')).toBe('John Smith');

         var firstRepeat =
             container.findElement(by.repeater('contact in contacts').row(0));
         var secondRepeat =
             container.findElement(by.repeater('contact in contacts').row(1));

         expect(firstRepeat.findElement(by.model('contact.value')).getAttribute('value'))
             .toBe('408 555 1212');
         expect(secondRepeat.findElement(by.model('contact.value')).getAttribute('value'))
             .toBe('john.smith@example.org');

         firstRepeat.findElement(by.linkText('clear')).click();

         expect(firstRepeat.findElement(by.model('contact.value')).getAttribute('value'))
             .toBe('');

         container.findElement(by.linkText('add')).click();

         expect(container.findElement(by.repeater('contact in contacts').row(2))
             .findElement(by.model('contact.value'))
             .getAttribute('value'))
             .toBe('yourname@example.org');
       });
     &lt;/file>
   &lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngCopy"><span class="type-signature"></span>ngCopy<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on copy event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18355">line 18355</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;input ng-copy="copied=true" ng-init="copied=false; value='copy me'" ng-model="value">
   copied: {{copied}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngCsp"><span class="type-signature"></span>ngCsp<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.

This is necessary when developing things like Google Chrome Extensions.

CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).
For us to be compatible, we just need to implement the "getterFn" in $parse without violating
any of these restrictions.

AngularJS uses `Function(string)` generated functions as a speed optimization. Applying the `ngCsp`
directive will cause Angular to use CSP compatibility mode. When this mode is on AngularJS will
evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
be raised.

CSP forbids JavaScript to inline stylesheet rules. In non CSP mode Angular automatically
includes some CSS rules (e.g. ngCloak).
To make those directives work in CSP mode, include the `angular-csp.css` manually.

In order to use this feature put the `ngCsp` directive on the root element of the application.

*Note: This directive is only available in the `ng-csp` and `data-ng-csp` attribute form.*
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17937">line 17937</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>This example shows how to apply the `ngCsp` directive to the `html` tag.
   ```html
     &lt;!doctype html>
     &lt;html ng-app ng-csp>
     ...
     ...
     &lt;/html>
   ```</code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngCut"><span class="type-signature"></span>ngCut<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on cut event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18376">line 18376</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;input ng-cut="cut=true" ng-init="cut=false; value='cut me'" ng-model="value">
   cut: {{cut}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngDblclick"><span class="type-signature"></span>ngDblclick<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18037">line 18037</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;button ng-dblclick="count = count + 1" ng-init="count=0">
     Increment (on double click)
   &lt;/button>
   count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngDisabled"><span class="type-signature"></span>ngDisabled<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
```html
<div ng-init="scope = { isDisabled: false }">
 <button disabled="{{scope.isDisabled}}">Disabled</button>
</div>
```

The HTML specification does not require browsers to preserve the values of boolean attributes
such as disabled. (Their presence means true and their absence means false.)
If we put an Angular interpolation expression into such an attribute then the
binding information would be lost when the browser removes the attribute.
The `ngDisabled` directive solves this problem for the `disabled` attribute.
This complementary directive is not removed by the browser and so provides
a permanent reliable place to store the binding information.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15067">line 15067</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    Click me to toggle: &lt;input type="checkbox" ng-model="checked">&lt;br/>
    &lt;button ng-model="button" ng-disabled="checked">Button&lt;/button>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should toggle button', function() {
      expect(element(by.css('button')).getAttribute('disabled')).toBeFalsy();
      element(by.model('checked')).click();
      expect(element(by.css('button')).getAttribute('disabled')).toBeTruthy();
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngFocus"><span class="type-signature"></span>ngFocus<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on focus event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18323">line 18323</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>See {@link ng.directive:ngClick ngClick}</code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngForm"><span class="type-signature"></span>ngForm<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Nestable alias of `form` directive. HTML
does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
sub-group of controls needs to be determined.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15505">line 15505</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngHide"><span class="type-signature"></span>ngHide<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngHide` directive shows or hides the given HTML element based on the expression
provided to the ngHide attribute. The element is shown or hidden by removing or adding
the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
in AngularJS and sets the display style to none (using an !important flag).
For CSP mode please add `angular-csp.css` to your html file (see ngCsp).

```hrml
<!-- when $scope.myValue is truthy (element is hidden) -->
<div ng-hide="myValue"></div>

<!-- when $scope.myValue is falsy (element is visible) -->
<div ng-hide="myValue" class="ng-hide"></div>
```

When the ngHide expression evaluates to true then the .ng-hide CSS class is added to the class attribute
on the element causing it to become hidden. When false, the ng-hide CSS class is removed
from the element causing the element not to appear hidden.

## Why is !important used?

You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
can be easily overridden by heavier selectors. For example, something as simple
as changing the display style on a HTML list item would make hidden elements appear visible.
This also becomes a bigger issue when dealing with CSS frameworks.

By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
styling to change how to hide an element then it is just a matter of using !important in their own CSS code.

### Overriding .ng-hide

If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
restating the styles for the .ng-hide class in CSS:
```css
.ng-hide {
  //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
  display:block!important;

  //this is just another form of hiding an element
  position:absolute;
  top:-9999px;
  left:-9999px;
}
```

Just remember to include the important flag so the CSS override will function.

<div class="alert alert-warning">
**Note:** Here is a list of values that ngHide will consider as a falsy value (case insensitive):<br />
"f" / "0" / "false" / "no" / "n" / "[]"
</div>

## A note about animations with ngHide

Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
is true and false. This system works like the animation system present with ngClass, except that
you must also include the !important flag to override the display property so
that you can perform an animation when the element is hidden during the time of the animation.

```css
//
//a working example can be found at the bottom of this page
//
.my-element.ng-hide-add, .my-element.ng-hide-remove {
  transition:0.5s linear all;
  display:block!important;
}

.my-element.ng-hide-add { ... }
.my-element.ng-hide-add.ng-hide-add-active { ... }
.my-element.ng-hide-remove { ... }
.my-element.ng-hide-remove.ng-hide-remove-active { ... }
```
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line19656">line 19656</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="ngAnimate" deps="angular-animate.js" animations="true">
  &lt;file name="index.html">
    Click me: &lt;input type="checkbox" ng-model="checked">&lt;br/>
    &lt;div>
      Show:
      &lt;div class="check-element animate-hide" ng-show="checked">
        &lt;span class="glyphicon glyphicon-thumbs-up">&lt;/span> I show up when your checkbox is checked.
      &lt;/div>
    &lt;/div>
    &lt;div>
      Hide:
      &lt;div class="check-element animate-hide" ng-hide="checked">
        &lt;span class="glyphicon glyphicon-thumbs-down">&lt;/span> I hide when your checkbox is checked.
      &lt;/div>
    &lt;/div>
  &lt;/file>
  &lt;file name="glyphicons.css">
    </code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngHref"><span class="type-signature"></span>ngHref<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Using Angular markup like `{{hash}}` in an href attribute will
make the link go to the wrong URL if the user clicks it before
Angular has a chance to replace the `{{hash}}` markup with its
value. Until Angular replaces the markup the link will be broken
and will most likely return a 404 error.

The `ngHref` directive solves this problem.

The wrong way to write it:
```html
<a href="http://www.gravatar.com/avatar/{{hash}}"/>
```

The correct way to write it:
```html
<a ng-href="http://www.gravatar.com/avatar/{{hash}}"/>
```
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14915">line 14915</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>This example shows various combinations of `href`, `ng-href` and `ng-click` attributes
in links and their different behaviors:
    &lt;example>
      &lt;file name="index.html">
        &lt;input ng-model="value" />&lt;br />
        &lt;a id="link-1" href ng-click="value = 1">link 1&lt;/a> (link, don't reload)&lt;br />
        &lt;a id="link-2" href="" ng-click="value = 2">link 2&lt;/a> (link, don't reload)&lt;br />
        &lt;a id="link-3" ng-href="/{{'123'}}">link 3&lt;/a> (link, reload!)&lt;br />
        &lt;a id="link-4" href="" name="xx" ng-click="value = 4">anchor&lt;/a> (link, don't reload)&lt;br />
        &lt;a id="link-5" name="xxx" ng-click="value = 5">anchor&lt;/a> (no link)&lt;br />
        &lt;a id="link-6" ng-href="{{value}}">link&lt;/a> (link, change location)
      &lt;/file>
      &lt;file name="protractor.js" type="protractor">
        it('should execute ng-click but not reload when href without value', function() {
          element(by.id('link-1')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('1');
          expect(element(by.id('link-1')).getAttribute('href')).toBe('');
        });

        it('should execute ng-click but not reload when href empty string', function() {
          element(by.id('link-2')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('2');
          expect(element(by.id('link-2')).getAttribute('href')).toBe('');
        });

        it('should execute ng-click and change url when ng-href specified', function() {
          expect(element(by.id('link-3')).getAttribute('href')).toMatch(/\/123$/);

          element(by.id('link-3')).click();

          // At this point, we navigate away from an Angular page, so we need
          // to use browser.driver to get the base webdriver.

          browser.wait(function() {
            return browser.driver.getCurrentUrl().then(function(url) {
              return url.match(/\/123$/);
            });
          }, 1000, 'page should navigate to /123');
        });

        xit('should execute ng-click but not reload when href empty string and name specified', function() {
          element(by.id('link-4')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('4');
          expect(element(by.id('link-4')).getAttribute('href')).toBe('');
        });

        it('should execute ng-click but not reload when no href but name specified', function() {
          element(by.id('link-5')).click();
          expect(element(by.model('value')).getAttribute('value')).toEqual('5');
          expect(element(by.id('link-5')).getAttribute('href')).toBe(null);
        });

        it('should only change url when only ng-href', function() {
          element(by.model('value')).clear();
          element(by.model('value')).sendKeys('6');
          expect(element(by.id('link-6')).getAttribute('href')).toMatch(/\/6$/);

          element(by.id('link-6')).click();

          // At this point, we navigate away from an Angular page, so we need
          // to use browser.driver to get the base webdriver.
          browser.wait(function() {
            return browser.driver.getCurrentUrl().then(function(url) {
              return url.match(/\/6$/);
            });
          }, 1000, 'page should navigate to /6');
        });
      &lt;/file>
    &lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngIf"><span class="type-signature"></span>ngIf<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngIf` directive removes or recreates a portion of the DOM tree based on an
{expression}. If the expression assigned to `ngIf` evaluates to a false
value then the element is removed from the DOM, otherwise a clone of the
element is reinserted into the DOM.

`ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
element in the DOM rather than changing its visibility via the `display` css property.  A common
case when this difference is significant is when using css selectors that rely on an element's
position within the DOM, such as the `:first-child` or `:last-child` pseudo-classes.

Note that when an element is removed using `ngIf` its scope is destroyed and a new scope
is created when the element is restored.  The scope created within `ngIf` inherits from
its parent scope using
[prototypal inheritance](https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance).
An important implication of this is if `ngModel` is used within `ngIf` to bind to
a javascript primitive defined in the parent scope. In this case any modifications made to the
variable within the child scope will override (hide) the value in the parent scope.

Also, `ngIf` recreates elements using their compiled state. An example of this behavior
is if an element's class attribute is directly modified after it's compiled, using something like
jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
the added class will be lost because the original compiled state is used to regenerate the element.

Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`
and `leave` effects.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18418">line 18418</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="ngAnimate" deps="angular-animate.js" animations="true">
  &lt;file name="index.html">
    Click me: &lt;input type="checkbox" ng-model="checked" ng-init="checked=true" />&lt;br/>
    Show when checked:
    &lt;span ng-if="checked" class="animate-if">
      I'm removed when the checkbox is unchecked.
    &lt;/span>
  &lt;/file>
  &lt;file name="animations.css">
    .animate-if {
      background:white;
      border:1px solid black;
      padding:10px;
    }

    .animate-if.ng-enter, .animate-if.ng-leave {
      -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
    }

    .animate-if.ng-enter,
    .animate-if.ng-leave.ng-leave-active {
      opacity:0;
    }

    .animate-if.ng-leave,
    .animate-if.ng-enter.ng-enter-active {
      opacity:1;
    }
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngInclude"><span class="type-signature"></span>ngInclude<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Fetches, compiles and includes an external HTML fragment.

By default, the template URL is restricted to the same domain and protocol as the
application document. This is done by calling $sce.getTrustedResourceUrl on it. To load templates from other domains or protocols
you may either whitelist them or
[wrap them](ng.$sce#methods_trustAsResourceUrl) as trusted values. Refer to Angular's Strict Contextual Escaping.

In addition, the browser's
[Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
policy may further restrict whether the template is successfully loaded.
For example, `ngInclude` won't work for cross-domain requests on all browsers and for `file://`
access on some browsers.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18536">line 18536</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="ngAnimate" deps="angular-animate.js" animations="true">
  &lt;file name="index.html">
   &lt;div ng-controller="Ctrl">
     &lt;select ng-model="template" ng-options="t.name for t in templates">
      &lt;option value="">(blank)&lt;/option>
     &lt;/select>
     url of the template: &lt;tt>{{template.url}}&lt;/tt>
     &lt;hr/>
     &lt;div class="slide-animate-container">
       &lt;div class="slide-animate" ng-include="template.url">&lt;/div>
     &lt;/div>
   &lt;/div>
  &lt;/file>
  &lt;file name="script.js">
    function Ctrl($scope) {
      $scope.templates =
        [ { name: 'template1.html', url: 'template1.html'},
          { name: 'template2.html', url: 'template2.html'} ];
      $scope.template = $scope.templates[0];
    }
   &lt;/file>
  &lt;file name="template1.html">
    Content of template1.html
  &lt;/file>
  &lt;file name="template2.html">
    Content of template2.html
  &lt;/file>
  &lt;file name="animations.css">
    .slide-animate-container {
      position:relative;
      background:white;
      border:1px solid black;
      height:40px;
      overflow:hidden;
    }

    .slide-animate {
      padding:10px;
    }

    .slide-animate.ng-enter, .slide-animate.ng-leave {
      -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      display:block;
      padding:10px;
    }

    .slide-animate.ng-enter {
      top:-50px;
    }
    .slide-animate.ng-enter.ng-enter-active {
      top:0;
    }

    .slide-animate.ng-leave {
      top:0;
    }
    .slide-animate.ng-leave.ng-leave-active {
      top:50px;
    }
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var templateSelect = element(by.model('template'));
    var includeElem = element(by.css('[ng-include]'));

    it('should load template1.html', function() {
      expect(includeElem.getText()).toMatch(/Content of template1.html/);
    });

    it('should load template2.html', function() {
      if (browser.params.browser == 'firefox') {
        // Firefox can't handle using selects
        // See https://github.com/angular/protractor/issues/480
        return;
      }
      templateSelect.click();
      templateSelect.element.all(by.css('option')).get(2).click();
      expect(includeElem.getText()).toMatch(/Content of template2.html/);
    });

    it('should change to blank', function() {
      if (browser.params.browser == 'firefox') {
        // Firefox can't handle using selects
        return;
      }
      templateSelect.click();
      templateSelect.element.all(by.css('option')).get(0).click();
      expect(includeElem.isPresent()).toBe(false);
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngInit"><span class="type-signature"></span>ngInit<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngInit` directive allows you to evaluate an expression in the
current scope.

<div class="alert alert-error">
The only appropriate use of `ngInit` is for aliasing special properties of
`ngRepeat`, as seen in the demo below. Besides this case, you
should use controllers rather than `ngInit`
to initialize values on a scope.
</div>
<div class="alert alert-warning">
**Note**: If you have assignment in `ngInit` along with `$filter`, make
sure you have parenthesis for correct precedence:
<pre class="prettyprint">
  <div ng-init="test1 = (data | orderBy:'name')"></div>
</pre>
</div>
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18788">line 18788</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
&lt;script>
  function Ctrl($scope) {
    $scope.list = [['a', 'b'], ['c', 'd']];
  }
&lt;/script>
&lt;div ng-controller="Ctrl">
  &lt;div ng-repeat="innerList in list" ng-init="outerIndex = $index">
    &lt;div ng-repeat="value in innerList" ng-init="innerIndex = $index">
       &lt;span class="example-init">list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};&lt;/span>
    &lt;/div>
  &lt;/div>
&lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should alias index positions', function() {
      var elements = element.all(by.css('.example-init'));
      expect(elements.get(0).getText()).toBe('list[ 0 ][ 0 ] = a;');
      expect(elements.get(1).getText()).toBe('list[ 0 ][ 1 ] = b;');
      expect(elements.get(2).getText()).toBe('list[ 1 ][ 0 ] = c;');
      expect(elements.get(3).getText()).toBe('list[ 1 ][ 1 ] = d;');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngKeydown"><span class="type-signature"></span>ngKeydown<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on keydown event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18204">line 18204</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;input ng-keydown="count = count + 1" ng-init="count=0">
   key down count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngKeypress"><span class="type-signature"></span>ngKeypress<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on keypress event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18248">line 18248</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;input ng-keypress="count = count + 1" ng-init="count=0">
   key press count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngKeyup"><span class="type-signature"></span>ngKeyup<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on keyup event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18226">line 18226</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;input ng-keyup="count = count + 1" ng-init="count=0">
   key up count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngList"><span class="type-signature"></span>ngList<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Text input that converts between a delimited string and an array of strings. The delimiter
can be a fixed string (by default a comma) or a regular expression.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17023">line 17023</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="ngList-directive">
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.names = ['igor', 'misko', 'vojta'];
     }
   &lt;/script>
   &lt;form name="myForm" ng-controller="Ctrl">
     List: &lt;input name="namesInput" ng-model="names" ng-list required>
     &lt;span class="error" ng-show="myForm.namesInput.$error.required">
       Required!&lt;/span>
     &lt;br>
     &lt;tt>names = {{names}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$valid = {{myForm.$valid}}&lt;/tt>&lt;br/>
     &lt;tt>myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt>&lt;br/>
    &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var listInput = element(by.model('names'));
    var names = element(by.binding('{{names}}'));
    var valid = element(by.binding('myForm.namesInput.$valid'));
    var error = element(by.css('span.error'));

    it('should initialize to model', function() {
      expect(names.getText()).toContain('["igor","misko","vojta"]');
      expect(valid.getText()).toContain('true');
      expect(error.getCssValue('display')).toBe('none');
    });

    it('should be invalid if empty', function() {
      listInput.clear();
      listInput.sendKeys('');

      expect(names.getText()).toContain('');
      expect(valid.getText()).toContain('false');
      expect(error.getCssValue('display')).not.toBe('none');        });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngModel"><span class="type-signature"></span>ngModel<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngModel` directive binds an `input`,`select`, `textarea` (or custom form control) to a
property on the scope using <a href="global.html#ngModel#NgModelController">NgModelController</a>,
which is created and exposed by this directive.

`ngModel` is responsible for:

- Binding the view into the model, which other directives such as `input`, `textarea` or `select`
  require.
- Providing validation behavior (i.e. required, number, email, url).
- Keeping the state of the control (valid/invalid, dirty/pristine, validation errors).
- Setting related css classes on the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`).
- Registering the control with its parent form.

Note: `ngModel` will try to bind to the property given by evaluating the expression on the
current scope. If the property doesn't already exist on this scope, it will be created
implicitly and added to the scope.

For best practices on using `ngModel`, see:

 - [https://github.com/angular/angular.js/wiki/Understanding-Scopes]

For basic examples, how to use `ngModel`, see:

 - input
   - {@link input[text] text}
   - <a href="global.html#input[checkbox]">checkbox</a>
   - <a href="global.html#input[radio]">radio</a>
   - <a href="global.html#input[number]">number</a>
   - <a href="global.html#input[email]">email</a>
   - <a href="global.html#input[url]">url</a>
 - select
 - {@link ng.directive:textarea textarea}
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line16866">line 16866</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngMousedown"><span class="type-signature"></span>ngMousedown<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The ngMousedown directive allows you to specify custom behavior on mousedown event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18061">line 18061</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;button ng-mousedown="count = count + 1" ng-init="count=0">
     Increment (on mouse down)
   &lt;/button>
   count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngMouseenter"><span class="type-signature"></span>ngMouseenter<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on mouseenter event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18132">line 18132</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;button ng-mouseenter="count = count + 1" ng-init="count=0">
     Increment (when mouse enters)
   &lt;/button>
   count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngMouseleave"><span class="type-signature"></span>ngMouseleave<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on mouseleave event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18156">line 18156</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;button ng-mouseleave="count = count + 1" ng-init="count=0">
     Increment (when mouse leaves)
   &lt;/button>
   count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngMouseover"><span class="type-signature"></span>ngMouseover<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on mouseover event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18108">line 18108</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;button ng-mouseover="count = count + 1" ng-init="count=0">
     Increment (when mouse is over)
   &lt;/button>
   count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngMouseup"><span class="type-signature"></span>ngMouseup<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on mouseup event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18085">line 18085</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;button ng-mouseup="count = count + 1" ng-init="count=0">
     Increment (on mouse up)
   &lt;/button>
   count: {{count}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngNonBindable"><span class="type-signature"></span>ngNonBindable<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngNonBindable` directive tells Angular not to compile or bind the contents of the current
DOM element. This is useful if the element contains what appears to be Angular directives and
bindings but which should be ignored by Angular. This could be the case if you have a site that
displays snippets of code, for instance.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18854">line 18854</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Examples</h5>
        
    <pre class="prettyprint"><code>In this example there are two locations where a simple interpolation binding (`{{}}`) is present,
but the one wrapped in `ngNonBindable` is left alone.</code></pre>

    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;div>Normal: {{1 + 2}}&lt;/div>
    &lt;div ng-non-bindable>Ignored: {{1 + 2}}&lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
   it('should check ng-non-bindable', function() {
     expect(element(by.binding('1 + 2')).getText()).toContain('3');
     expect(element.all(by.css('div')).last().getText()).toMatch(/1 \+ 2/);
   });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngOpen"><span class="type-signature"></span>ngOpen<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The HTML specification does not require browsers to preserve the values of boolean attributes
such as open. (Their presence means true and their absence means false.)
If we put an Angular interpolation expression into such an attribute then the
binding information would be lost when the browser removes the attribute.
The `ngOpen` directive solves this problem for the `open` attribute.
This complementary directive is not removed by the browser and so provides
a permanent reliable place to store the binding information.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15219">line 15219</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    Check me check multiple: &lt;input type="checkbox" ng-model="open">&lt;br/>
    &lt;details id="details" ng-open="open">
       &lt;summary>Show/Hide me&lt;/summary>
    &lt;/details>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should toggle open', function() {
      expect(element(by.id('details')).getAttribute('open')).toBeFalsy();
      element(by.model('open')).click();
      expect(element(by.id('details')).getAttribute('open')).toBeTruthy();
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngPaste"><span class="type-signature"></span>ngPaste<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Specify custom behavior on paste event.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18397">line 18397</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;input ng-paste="paste=true" ng-init="paste=false" placeholder='paste here'>
   pasted: {{paste}}
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngPluralize"><span class="type-signature"></span>ngPluralize<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        `ngPluralize` is a directive that displays messages according to en-US localization rules.
These rules are bundled with angular.js, but can be overridden
(see Angular i18n dev guide). You configure ngPluralize directive
by specifying the mappings between
[plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
and the strings to be displayed.

# Plural categories and explicit number rules
There are two
[plural categories](http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html)
in Angular's default en-US locale: "one" and "other".

While a plural category may match many numbers (for example, in en-US locale, "other" can match
any number that is not 1), an explicit number rule can only match one number. For example, the
explicit number rule for "3" matches the number 3. There are examples of plural categories
and explicit number rules throughout the rest of this documentation.

# Configuring ngPluralize
You configure ngPluralize by providing 2 attributes: `count` and `when`.
You can also provide an optional attribute, `offset`.

The value of the `count` attribute can be either a string or an Angular expression; these are evaluated on the current scope for its bound value.

The `when` attribute specifies the mappings between plural categories and the actual
string to be displayed. The value of the attribute should be a JSON object.

The following example shows how to configure ngPluralize:

```html
<ng-pluralize count="personCount"
                 when="{'0': 'Nobody is viewing.',
                     'one': '1 person is viewing.',
                     'other': '{} people are viewing.'}">
</ng-pluralize>
```

In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
other numbers, for example 12, so that instead of showing "12 people are viewing", you can
show "a dozen people are viewing".

You can use a set of closed braces (`{}`) as a placeholder for the number that you want substituted
into pluralized strings. In the previous example, Angular will replace `{}` with
<span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
for <span ng-non-bindable>{{numberExpression}}</span>.

# Configuring ngPluralize with offset
The `offset` attribute allows further customization of pluralized text, which can result in
a better user experience. For example, instead of the message "4 people are viewing this document",
you might display "John, Kate and 2 others are viewing this document".
The offset attribute allows you to offset a number by any desired value.
Let's take a look at an example:

```html
<ng-pluralize count="personCount" offset=2
              when="{'0': 'Nobody is viewing.',
                     '1': '{{person1}} is viewing.',
                     '2': '{{person1}} and {{person2}} are viewing.',
                     'one': '{{person1}}, {{person2}} and one other person are viewing.',
                     'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
</ng-pluralize>
```

Notice that we are still using two plural categories(one, other), but we added
three explicit number rules 0, 1 and 2.
When one person, perhaps John, views the document, "John is viewing" will be shown.
When three people view the document, no explicit number rule is found, so
an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
In this case, plural category 'one' is matched and "John, Marry and one other person are viewing"
is shown.

Note that when you specify offsets, you must provide explicit number rules for
numbers from 0 up to and including the offset. If you use an offset of 3, for example,
you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
plural categories "one" and "other".
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18888">line 18888</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script>
      function Ctrl($scope) {
        $scope.person1 = 'Igor';
        $scope.person2 = 'Misko';
        $scope.personCount = 1;
      }
    &lt;/script>
    &lt;div ng-controller="Ctrl">
      Person 1:&lt;input type="text" ng-model="person1" value="Igor" />&lt;br/>
      Person 2:&lt;input type="text" ng-model="person2" value="Misko" />&lt;br/>
      Number of People:&lt;input type="text" ng-model="personCount" value="1" />&lt;br/>

      &lt;!--- Example with simple pluralization rules for en locale --->
      Without Offset:
      &lt;ng-pluralize count="personCount"
                    when="{'0': 'Nobody is viewing.',
                           'one': '1 person is viewing.',
                           'other': '{} people are viewing.'}">
      &lt;/ng-pluralize>&lt;br>

      &lt;!--- Example with offset --->
      With Offset(2):
      &lt;ng-pluralize count="personCount" offset=2
                    when="{'0': 'Nobody is viewing.',
                           '1': '{{person1}} is viewing.',
                           '2': '{{person1}} and {{person2}} are viewing.',
                           'one': '{{person1}}, {{person2}} and one other person are viewing.',
                           'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
      &lt;/ng-pluralize>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should show correct pluralized string', function() {
      var withoutOffset = element.all(by.css('ng-pluralize')).get(0);
      var withOffset = element.all(by.css('ng-pluralize')).get(1);
      var countInput = element(by.model('personCount'));

      expect(withoutOffset.getText()).toEqual('1 person is viewing.');
      expect(withOffset.getText()).toEqual('Igor is viewing.');

      countInput.clear();
      countInput.sendKeys('0');

      expect(withoutOffset.getText()).toEqual('Nobody is viewing.');
      expect(withOffset.getText()).toEqual('Nobody is viewing.');

      countInput.clear();
      countInput.sendKeys('2');

      expect(withoutOffset.getText()).toEqual('2 people are viewing.');
      expect(withOffset.getText()).toEqual('Igor and Misko are viewing.');

      countInput.clear();
      countInput.sendKeys('3');

      expect(withoutOffset.getText()).toEqual('3 people are viewing.');
      expect(withOffset.getText()).toEqual('Igor, Misko and one other person are viewing.');

      countInput.clear();
      countInput.sendKeys('4');

      expect(withoutOffset.getText()).toEqual('4 people are viewing.');
      expect(withOffset.getText()).toEqual('Igor, Misko and 2 other people are viewing.');
    });
    it('should show data-bound names', function() {
      var withOffset = element.all(by.css('ng-pluralize')).get(1);
      var personCount = element(by.model('personCount'));
      var person1 = element(by.model('person1'));
      var person2 = element(by.model('person2'));
      personCount.clear();
      personCount.sendKeys('4');
      person1.clear();
      person1.sendKeys('Di');
      person2.clear();
      person2.sendKeys('Vojta');
      expect(withOffset.getText()).toEqual('Di, Vojta and 2 other people are viewing.');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngReadonly"><span class="type-signature"></span>ngReadonly<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The HTML specification does not require browsers to preserve the values of boolean attributes
such as readonly. (Their presence means true and their absence means false.)
If we put an Angular interpolation expression into such an attribute then the
binding information would be lost when the browser removes the attribute.
The `ngReadonly` directive solves this problem for the `readonly` attribute.
This complementary directive is not removed by the browser and so provides
a permanent reliable place to store the binding information.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15146">line 15146</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    Check me to make text readonly: &lt;input type="checkbox" ng-model="checked">&lt;br/>
    &lt;input type="text" ng-readonly="checked" value="I'm Angular"/>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should toggle readonly attr', function() {
      expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeFalsy();
      element(by.model('checked')).click();
      expect(element(by.css('[type="text"]')).getAttribute('readonly')).toBeTruthy();
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngRepeat"><span class="type-signature"></span>ngRepeat<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngRepeat` directive instantiates a template once per item from a collection. Each template
instance gets its own scope, where the given loop variable is set to the current collection item,
and `$index` is set to the item index or key.

Special properties are exposed on the local scope of each template instance, including:

| Variable  | Type            | Details                                                                     |
|-----------|-----------------|-----------------------------------------------------------------------------|
| `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
| `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
| `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
| `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
| `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
| `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |

Creating aliases for these properties is possible with `ngInit`.
This may be useful when, for instance, nesting ngRepeats.

# Special repeat start and end points
To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)
up to and including the ending HTML tag where **ng-repeat-end** is placed.

The example below makes use of this feature:
```html
  <header ng-repeat-start="item in items">
    Header {{ item }}
  </header>
  <div class="body">
    Body {{ item }}
  </div>
  <footer ng-repeat-end>
    Footer {{ item }}
  </footer>
```

And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
```html
  <header>
    Header A
  </header>
  <div class="body">
    Body A
  </div>
  <footer>
    Footer A
  </footer>
  <header>
    Header B
  </header>
  <div class="body">
    Body B
  </div>
  <footer>
    Footer B
  </footer>
```

The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such
as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line19103">line 19103</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>This example initializes the scope to a list of names and
then uses `ngRepeat` to display every person:
  &lt;example module="ngAnimate" deps="angular-animate.js" animations="true">
    &lt;file name="index.html">
      &lt;div ng-init="friends = [
        {name:'John', age:25, gender:'boy'},
        {name:'Jessie', age:30, gender:'girl'},
        {name:'Johanna', age:28, gender:'girl'},
        {name:'Joy', age:15, gender:'girl'},
        {name:'Mary', age:28, gender:'girl'},
        {name:'Peter', age:95, gender:'boy'},
        {name:'Sebastian', age:50, gender:'boy'},
        {name:'Erika', age:27, gender:'girl'},
        {name:'Patrick', age:40, gender:'boy'},
        {name:'Samantha', age:60, gender:'girl'}
      ]">
        I have {{friends.length}} friends. They are:
        &lt;input type="search" ng-model="q" placeholder="filter friends..." />
        &lt;ul class="example-animate-container">
          &lt;li class="animate-repeat" ng-repeat="friend in friends | filter:q">
            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
          &lt;/li>
        &lt;/ul>
      &lt;/div>
    &lt;/file>
    &lt;file name="animations.css">
      .example-animate-container {
        background:white;
        border:1px solid black;
        list-style:none;
        margin:0;
        padding:0 10px;
      }

      .animate-repeat {
        line-height:40px;
        list-style:none;
        box-sizing:border-box;
      }

      .animate-repeat.ng-move,
      .animate-repeat.ng-enter,
      .animate-repeat.ng-leave {
        -webkit-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

      .animate-repeat.ng-leave.ng-leave-active,
      .animate-repeat.ng-move,
      .animate-repeat.ng-enter {
        opacity:0;
        max-height:0;
      }

      .animate-repeat.ng-leave,
      .animate-repeat.ng-move.ng-move-active,
      .animate-repeat.ng-enter.ng-enter-active {
        opacity:1;
        max-height:40px;
      }
    &lt;/file>
    &lt;file name="protractor.js" type="protractor">
      var friends = element.all(by.repeater('friend in friends'));

      it('should render initial data set', function() {
        expect(friends.count()).toBe(10);
        expect(friends.get(0).getText()).toEqual('[1] John who is 25 years old.');
        expect(friends.get(1).getText()).toEqual('[2] Jessie who is 30 years old.');
        expect(friends.last().getText()).toEqual('[10] Samantha who is 60 years old.');
        expect(element(by.binding('friends.length')).getText())
            .toMatch("I have 10 friends. They are:");
      });

       it('should update repeater when filter predicate changes', function() {
         expect(friends.count()).toBe(10);

         element(by.model('q')).sendKeys('ma');

         expect(friends.count()).toBe(2);
         expect(friends.get(0).getText()).toEqual('[1] Mary who is 28 years old.');
         expect(friends.last().getText()).toEqual('[2] Samantha who is 60 years old.');
       });
      &lt;/file>
    &lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngSelected"><span class="type-signature"></span>ngSelected<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The HTML specification does not require browsers to preserve the values of boolean attributes
such as selected. (Their presence means true and their absence means false.)
If we put an Angular interpolation expression into such an attribute then the
binding information would be lost when the browser removes the attribute.
The `ngSelected` directive solves this problem for the `selected` atttribute.
This complementary directive is not removed by the browser and so provides
a permanent reliable place to store the binding information.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15181">line 15181</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    Check me to select: &lt;input type="checkbox" ng-model="selected">&lt;br/>
    &lt;select>
      &lt;option>Hello!&lt;/option>
      &lt;option id="greet" ng-selected="selected">Greetings!&lt;/option>
    &lt;/select>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should select Greetings!', function() {
      expect(element(by.id('greet')).getAttribute('selected')).toBeFalsy();
      element(by.model('selected')).click();
      expect(element(by.id('greet')).getAttribute('selected')).toBeTruthy();
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngShow"><span class="type-signature"></span>ngShow<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngShow` directive shows or hides the given HTML element based on the expression
provided to the ngShow attribute. The element is shown or hidden by removing or adding
the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
in AngularJS and sets the display style to none (using an !important flag).
For CSP mode please add `angular-csp.css` to your html file (see ngCsp).

```html
<!-- when $scope.myValue is truthy (element is visible) -->
<div ng-show="myValue"></div>

<!-- when $scope.myValue is falsy (element is hidden) -->
<div ng-show="myValue" class="ng-hide"></div>
```

When the ngShow expression evaluates to false then the ng-hide CSS class is added to the class attribute
on the element causing it to become hidden. When true, the ng-hide CSS class is removed
from the element causing the element not to appear hidden.

## Why is !important used?

You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
can be easily overridden by heavier selectors. For example, something as simple
as changing the display style on a HTML list item would make hidden elements appear visible.
This also becomes a bigger issue when dealing with CSS frameworks.

By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
styling to change how to hide an element then it is just a matter of using !important in their own CSS code.

### Overriding .ng-hide

If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
restating the styles for the .ng-hide class in CSS:
```css
.ng-hide {
  //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
  display:block!important;

  //this is just another form of hiding an element
  position:absolute;
  top:-9999px;
  left:-9999px;
}
```

Just remember to include the important flag so the CSS override will function.

<div class="alert alert-warning">
**Note:** Here is a list of values that ngShow will consider as a falsy value (case insensitive):<br />
"f" / "0" / "false" / "no" / "n" / "[]"
</div>

## A note about animations with ngShow

Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
is true and false. This system works like the animation system present with ngClass except that
you must also include the !important flag to override the display property
so that you can perform an animation when the element is hidden during the time of the animation.

```css
//
//a working example can be found at the bottom of this page
//
.my-element.ng-hide-add, .my-element.ng-hide-remove {
  transition:0.5s linear all;
  display:block!important;
}

.my-element.ng-hide-add { ... }
.my-element.ng-hide-add.ng-hide-add-active { ... }
.my-element.ng-hide-remove { ... }
.my-element.ng-hide-remove.ng-hide-remove-active { ... }
```
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line19496">line 19496</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="ngAnimate" deps="angular-animate.js" animations="true">
  &lt;file name="index.html">
    Click me: &lt;input type="checkbox" ng-model="checked">&lt;br/>
    &lt;div>
      Show:
      &lt;div class="check-element animate-show" ng-show="checked">
        &lt;span class="glyphicon glyphicon-thumbs-up">&lt;/span> I show up when your checkbox is checked.
      &lt;/div>
    &lt;/div>
    &lt;div>
      Hide:
      &lt;div class="check-element animate-show" ng-hide="checked">
        &lt;span class="glyphicon glyphicon-thumbs-down">&lt;/span> I hide when your checkbox is checked.
      &lt;/div>
    &lt;/div>
  &lt;/file>
  &lt;file name="glyphicons.css">
    </code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngSrc"><span class="type-signature"></span>ngSrc<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Using Angular markup like `{{hash}}` in a `src` attribute doesn't
work right: The browser will fetch from the URL with the literal
text `{{hash}}` until Angular replaces the expression inside
`{{hash}}`. The `ngSrc` directive solves this problem.

The buggy way to write it:
```html
<img src="http://www.gravatar.com/avatar/{{hash}}"/>
```

The correct way to write it:
```html
<img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
```
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15015">line 15015</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngSrcset"><span class="type-signature"></span>ngSrcset<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
work right: The browser will fetch from the URL with the literal
text `{{hash}}` until Angular replaces the expression inside
`{{hash}}`. The `ngSrcset` directive solves this problem.

The buggy way to write it:
```html
<img srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
```

The correct way to write it:
```html
<img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
```
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line15041">line 15041</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngStyle"><span class="type-signature"></span>ngStyle<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line19815">line 19815</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
     &lt;input type="button" value="set" ng-click="myStyle={color:'red'}">
     &lt;input type="button" value="clear" ng-click="myStyle={}">
     &lt;br/>
     &lt;span ng-style="myStyle">Sample Text&lt;/span>
     &lt;pre>myStyle={{myStyle}}&lt;/pre>
  &lt;/file>
  &lt;file name="style.css">
    span {
      color: black;
    }
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var colorSpan = element(by.css('span'));

    it('should check ng-style', function() {
      expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');
      element(by.css('input[value=set]')).click();
      expect(colorSpan.getCssValue('color')).toBe('rgba(255, 0, 0, 1)');
      element(by.css('input[value=clear]')).click();
      expect(colorSpan.getCssValue('color')).toBe('rgba(0, 0, 0, 1)');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngSubmit"><span class="type-signature"></span>ngSubmit<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Enables binding angular expressions to onsubmit events.

Additionally it prevents the default action (which for form means sending the request to the
server and reloading the current page), but only if the form does not contain `action`,
`data-action`, or `x-action` attributes.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line18269">line 18269</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
   &lt;script>
     function Ctrl($scope) {
       $scope.list = [];
       $scope.text = 'hello';
       $scope.submit = function() {
         if (this.text) {
           this.list.push(this.text);
           this.text = '';
         }
       };
     }
   &lt;/script>
   &lt;form ng-submit="submit()" ng-controller="Ctrl">
     Enter text and hit enter:
     &lt;input type="text" ng-model="text" name="text" />
     &lt;input type="submit" id="submit" value="Submit" />
     &lt;pre>list={{list}}&lt;/pre>
   &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should check ng-submit', function() {
      expect(element(by.binding('list')).getText()).toBe('list=[]');
      element(by.css('#submit')).click();
      expect(element(by.binding('list')).getText()).toContain('hello');
      expect(element(by.input('text')).getAttribute('value')).toBe('');
    });
    it('should ignore empty strings', function() {
      expect(element(by.binding('list')).getText()).toBe('list=[]');
      element(by.css('#submit')).click();
      element(by.css('#submit')).click();
      expect(element(by.binding('list')).getText()).toContain('hello');
     });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngSwitch"><span class="type-signature"></span>ngSwitch<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        The `ngSwitch` directive is used to conditionally swap DOM structure on your template based on a scope expression.
Elements within `ngSwitch` but without `ngSwitchWhen` or `ngSwitchDefault` directives will be preserved at the location
as specified in the template.

The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
from the template cache), `ngSwitch` simply chooses one of the nested elements and makes it visible based on which element
matches the value obtained from the evaluated expression. In other words, you define a container element
(where you place the directive), place an expression on the **`on="..."` attribute**
(or the **`ng-switch="..."` attribute**), define any inner elements inside of the directive and place
a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
attribute is displayed.

<div class="alert alert-info">
Be aware that the attribute values to match against cannot be expressions. They are interpreted
as literal string values to match against.
For example, **`ng-switch-when="someVal"`** will match against the string `"someVal"` not against the
value of the expression `$scope.someVal`.
</div>
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line19864">line 19864</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="ngAnimate" deps="angular-animate.js" animations="true">
  &lt;file name="index.html">
    &lt;div ng-controller="Ctrl">
      &lt;select ng-model="selection" ng-options="item for item in items">
      &lt;/select>
      &lt;tt>selection={{selection}}&lt;/tt>
      &lt;hr/>
      &lt;div class="animate-switch-container"
        ng-switch on="selection">
          &lt;div class="animate-switch" ng-switch-when="settings">Settings Div&lt;/div>
          &lt;div class="animate-switch" ng-switch-when="home">Home Span&lt;/div>
          &lt;div class="animate-switch" ng-switch-default>default&lt;/div>
      &lt;/div>
    &lt;/div>
  &lt;/file>
  &lt;file name="script.js">
    function Ctrl($scope) {
      $scope.items = ['settings', 'home', 'other'];
      $scope.selection = $scope.items[0];
    }
  &lt;/file>
  &lt;file name="animations.css">
    .animate-switch-container {
      position:relative;
      background:white;
      border:1px solid black;
      height:40px;
      overflow:hidden;
    }

    .animate-switch {
      padding:10px;
    }

    .animate-switch.ng-animate {
      -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
    }

    .animate-switch.ng-leave.ng-leave-active,
    .animate-switch.ng-enter {
      top:-50px;
    }
    .animate-switch.ng-leave,
    .animate-switch.ng-enter.ng-enter-active {
      top:0;
    }
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var switchElem = element(by.css('[ng-switch]'));
    var select = element(by.model('selection'));

    it('should start in settings', function() {
      expect(switchElem.getText()).toMatch(/Settings Div/);
    });
    it('should change to home', function() {
      select.element.all(by.css('option')).get(1).click();
      expect(switchElem.getText()).toMatch(/Home Span/);
    });
    it('should select default', function() {
      select.element.all(by.css('option')).get(2).click();
      expect(switchElem.getText()).toMatch(/default/);
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngTransclude"><span class="type-signature"></span>ngTransclude<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.

Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line20051">line 20051</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="transclude">
  &lt;file name="index.html">
    &lt;script>
      function Ctrl($scope) {
        $scope.title = 'Lorem Ipsum';
        $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
      }

      angular.module('transclude', [])
       .directive('pane', function(){
          return {
            restrict: 'E',
            transclude: true,
            scope: { title:'@' },
            template: '&lt;div style="border: 1px solid black;">' +
                        '&lt;div style="background-color: gray">{{title}}&lt;/div>' +
                        '&lt;div ng-transclude>&lt;/div>' +
                      '&lt;/div>'
          };
      });
    &lt;/script>
    &lt;div ng-controller="Ctrl">
      &lt;input ng-model="title">&lt;br>
      &lt;textarea ng-model="text">&lt;/textarea> &lt;br/>
      &lt;pane title="{{title}}">{{text}}&lt;/pane>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
     it('should have transcluded', function() {
       var titleElement = element(by.model('title'));
       titleElement.clear();
       titleElement.sendKeys('TITLE');
       var textElement = element(by.model('text'));
       textElement.clear();
       textElement.sendKeys('TEXT');
       expect(element(by.binding('title')).getText()).toEqual('TITLE');
       expect(element(by.binding('text')).getText()).toEqual('TEXT');
     });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ngValue"><span class="type-signature"></span>ngValue<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Binds the given expression to the value of `input[select]` or `input[radio]`, so
that when the element is selected, the `ngModel` of that element is set to the
bound value.

`ngValue` is useful when dynamically generating lists of radio buttons using `ng-repeat`, as
shown below.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line17118">line 17118</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example name="ngValue-directive">
  &lt;file name="index.html">
   &lt;script>
      function Ctrl($scope) {
        $scope.names = ['pizza', 'unicorns', 'robots'];
        $scope.my = { favorite: 'unicorns' };
      }
   &lt;/script>
    &lt;form ng-controller="Ctrl">
      &lt;h2>Which is your favorite?&lt;/h2>
        &lt;label ng-repeat="name in names" for="{{name}}">
          {{name}}
          &lt;input type="radio"
                 ng-model="my.favorite"
                 ng-value="name"
                 id="{{name}}"
                 name="favorite">
        &lt;/label>
      &lt;div>You chose {{my.favorite}}&lt;/div>
    &lt;/form>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var favorite = element(by.binding('my.favorite'));

    it('should initialize to model', function() {
      expect(favorite.getText()).toContain('unicorns');
    });
    it('should bind the values to the inputs', function() {
      element.all(by.model('my.favorite')).get(0).click();
      expect(favorite.getText()).toContain('pizza');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="script"><span class="type-signature"></span>script<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        Load the content of a `<script>` element into `$templateCache`, so that the
template can be used by `ngInclude`,
{@link ngRoute.directive:ngView `ngView`}, or directives. The type of the
`<script>` element must be specified as `text/ng-template`, and a cache name for the template must be
assigned through the element's `id`, which can then be used as a directive's `templateUrl`.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line20123">line 20123</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script type="text/ng-template" id="/tpl.html">
      Content of the template.
    &lt;/script>

    &lt;a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template&lt;/a>
    &lt;div id="tpl-content" ng-include src="currentTpl">&lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should load template defined inside script tag', function() {
      element(by.css('#tpl-link')).click();
      expect(element(by.css('#tpl-content')).getText()).toMatch(/Content of the template/);
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="select"><span class="type-signature"></span>select<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        HTML `SELECT` element with angular data-binding.

# `ngOptions`

The `ngOptions` attribute can be used to dynamically generate a list of `<option>`
elements for the `<select>` element using the array or object obtained by evaluating the
`ngOptions` comprehension_expression.

When an item in the `<select>` menu is selected, the array element or object property
represented by the selected option will be bound to the model identified by the `ngModel`
directive.

<div class="alert alert-warning">
**Note:** `ngModel` compares by reference, not value. This is important when binding to an
array of objects. See an example [in this jsfiddle](http://jsfiddle.net/qWzTb/).
</div>

Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
be nested into the `<select>` element. This element will then represent the `null` or "not selected"
option. See example below for demonstration.

<div class="alert alert-warning">
**Note:** `ngOptions` provides an iterator facility for the `<option>` element which should be used instead
of ngRepeat when you want the
`select` model to be bound to a non-string value. This is because an option element can only
be bound to string values at present.
</div>
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line20173">line 20173</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script>
    function MyCntrl($scope) {
      $scope.colors = [
        {name:'black', shade:'dark'},
        {name:'white', shade:'light'},
        {name:'red', shade:'dark'},
        {name:'blue', shade:'dark'},
        {name:'yellow', shade:'light'}
      ];
      $scope.color = $scope.colors[2]; // red
    }
    &lt;/script>
    &lt;div ng-controller="MyCntrl">
      &lt;ul>
        &lt;li ng-repeat="color in colors">
          Name: &lt;input ng-model="color.name">
          [&lt;a href ng-click="colors.splice($index, 1)">X&lt;/a>]
        &lt;/li>
        &lt;li>
          [&lt;a href ng-click="colors.push({})">add&lt;/a>]
        &lt;/li>
      &lt;/ul>
      &lt;hr/>
      Color (null not allowed):
      &lt;select ng-model="color" ng-options="c.name for c in colors">&lt;/select>&lt;br>

      Color (null allowed):
      &lt;span  class="nullable">
        &lt;select ng-model="color" ng-options="c.name for c in colors">
          &lt;option value="">-- choose color --&lt;/option>
        &lt;/select>
      &lt;/span>&lt;br/>

      Color grouped by shade:
      &lt;select ng-model="color" ng-options="c.name group by c.shade for c in colors">
      &lt;/select>&lt;br/>


      Select &lt;a href ng-click="color={name:'not in list'}">bogus&lt;/a>.&lt;br>
      &lt;hr/>
      Currently selected: {{ {selected_color:color}  }}
      &lt;div style="border:solid 1px black; height:20px"
           ng-style="{'background-color':color.name}">
      &lt;/div>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
     it('should check ng-options', function() {
       expect(element(by.binding('{selected_color:color}')).getText()).toMatch('red');
       element.all(by.select('color')).first().click();
       element.all(by.css('select[ng-model="color"] option')).first().click();
       expect(element(by.binding('{selected_color:color}')).getText()).toMatch('black');
       element(by.css('.nullable select[ng-model="color"]')).click();
       element.all(by.css('.nullable select[ng-model="color"] option')).first().click();
       expect(element(by.binding('{selected_color:color}')).getText()).toMatch('null');
     });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="textarea"><span class="type-signature"></span>textarea<span class="type-signature"></span></h4>

    
</dt>
<dd>
    
    <div class="description">
        HTML textarea element control with angular data-binding. The data-binding and validation
properties of this element are exactly the same as those of the
input element.
    </div>
    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line16372">line 16372</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    
</dd>

        </dl>
    

    
        <h3 class="subsection-title">Methods</h3>

        <dl>
            
<dt>
    <h4 class="name" id="$anchorScroll"><span class="type-signature"></span>$anchorScroll<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        When called, it checks current value of `$location.hash()` and scroll to related element,
according to rules specified in
[Html5 spec](http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document).

It also watches the `$location.hash()` and scrolls whenever it changes to match any anchor.
This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line3781">line 3781</a>
    </li></ul></dd>
    

    

    

    
</dl>


    
    <h5>Requires:</h5>
    <ul>
        <li>module:$window</li>
    
        <li>module:$location</li>
    
        <li>module:$rootScope</li>
    </ul>
    

    

    

    

    

    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;div id="scrollArea" ng-controller="ScrollCtrl">
      &lt;a ng-click="gotoBottom()">Go to bottom&lt;/a>
      &lt;a id="bottom">&lt;/a> You're at the bottom!
    &lt;/div>
  &lt;/file>
  &lt;file name="script.js">
    function ScrollCtrl($scope, $location, $anchorScroll) {
      $scope.gotoBottom = function (){
        // set the location.hash to the id of
        // the element you wish to scroll to.
        $location.hash('bottom');

        // call $anchorScroll()
        $anchorScroll();
      };
    }
  &lt;/file>
  &lt;file name="style.css">
    #scrollArea {
      height: 350px;
      overflow: auto;
    }

    #bottom {
      display: block;
      margin-top: 2000px;
    }
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="$compile"><span class="type-signature"></span>$compile<span class="signature">(element, maxPriority)</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Compiles an HTML string or DOM into a template and produces a template function, which
can then be used to link `scope` and the template together.

The compilation is a process of walking the DOM tree and matching DOM elements to
directives.

<div class="alert alert-warning">
**Note:** This document is an in-depth reference of all directive options.
For a gentle introduction to directives with examples of common use cases,
see the directive guide.
</div>

## Comprehensive Directive API

There are many different options for a directive.

The difference resides in the return value of the factory function.
You can either return a "Directive Definition Object" (see below) that defines the directive properties,
or just the `postLink` function (all other properties will have the default values).

<div class="alert alert-success">
**Best Practice:** It's recommended to use the "directive definition object" form.
</div>

Here's an example directive declared with a Directive Definition Object:

```js
  var myModule = angular.module(...);

  myModule.directive('directiveName', function factory(injectables) {
    var directiveDefinitionObject = {
      priority: 0,
      template: '<div></div>', // or // function(tElement, tAttrs) { ... },
      // or
      // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
      replace: false,
      transclude: false,
      restrict: 'A',
      scope: false,
      controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
      require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
      compile: function compile(tElement, tAttrs, transclude) {
        return {
          pre: function preLink(scope, iElement, iAttrs, controller) { ... },
          post: function postLink(scope, iElement, iAttrs, controller) { ... }
        }
        // or
        // return function postLink( ... ) { ... }
      },
      // or
      // link: {
      //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
      //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
      // }
      // or
      // link: function postLink( ... ) { ... }
    };
    return directiveDefinitionObject;
  });
```

<div class="alert alert-warning">
**Note:** Any unspecified options will use the default value. You can see the default values below.
</div>

Therefore the above can be simplified as:

```js
  var myModule = angular.module(...);

  myModule.directive('directiveName', function factory(injectables) {
    var directiveDefinitionObject = {
      link: function postLink(scope, iElement, iAttrs) { ... }
    };
    return directiveDefinitionObject;
    // or
    // return function postLink(scope, iElement, iAttrs) { ... }
  });
```



### Directive Definition Object

The directive definition object provides instructions to the compiler. The attributes are:

#### `priority`
When there are multiple directives defined on a single DOM element, sometimes it
is necessary to specify the order in which the directives are applied. The `priority` is used
to sort the directives before their `compile` functions get called. Priority is defined as a
number. Directives with greater numerical `priority` are compiled first. Pre-link functions
are also run in priority order, but post-link functions are run in reverse order. The order
of directives with the same priority is undefined. The default priority is `0`.

#### `terminal`
If set to true then the current `priority` will be the last set of directives
which will execute (any directives at the current priority will still execute
as the order of execution on same `priority` is undefined).

#### `scope`
**If set to `true`,** then a new scope will be created for this directive. If multiple directives on the
same element request a new scope, only one new scope is created. The new scope rule does not
apply for the root of the template since the root of the template always gets a new scope.

**If set to `{}` (object hash),** then a new "isolate" scope is created. The 'isolate' scope differs from
normal scope in that it does not prototypically inherit from the parent scope. This is useful
when creating reusable components, which should not accidentally read or modify data in the
parent scope.

The 'isolate' scope takes an object hash which defines a set of local scope properties
derived from the parent scope. These local properties are useful for aliasing values for
templates. Locals definition is a hash of local scope property to its source:

* `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is
  always a string since DOM attributes are strings. If no `attr` name is specified  then the
  attribute name is assumed to be the same as the local name.
  Given `<widget my-attr="hello {{name}}">` and widget definition
  of `scope: { localName:'@myAttr' }`, then widget scope property `localName` will reflect
  the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the
  `localName` property on the widget scope. The `name` is read from the parent scope (not
  component scope).

* `=` or `=attr` - set up bi-directional binding between a local scope property and the
  parent scope property of name defined via the value of the `attr` attribute. If no `attr`
  name is specified then the attribute name is assumed to be the same as the local name.
  Given `<widget my-attr="parentModel">` and widget definition of
  `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the
  value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected
  in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent
  scope property doesn't exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You
  can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional.

* `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.
  If no `attr` name is specified then the attribute name is assumed to be the same as the
  local name. Given `<widget my-attr="count = count + value">` and widget definition of
  `scope: { localFn:'&myAttr' }`, then isolate scope property `localFn` will point to
  a function wrapper for the `count = count + value` expression. Often it's desirable to
  pass data from the isolated scope via an expression and to the parent scope, this can be
  done by passing a map of local variable names and values into the expression wrapper fn.
  For example, if the expression is `increment(amount)` then we can specify the amount value
  by calling the `localFn` as `localFn({amount: 22})`.



#### `controller`
Controller constructor function. The controller is instantiated before the
pre-linking phase and it is shared with other directives (see
`require` attribute). This allows the directives to communicate with each other and augment
each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:

* `$scope` - Current scope associated with the element
* `$element` - Current element
* `$attrs` - Current attributes object for the element
* `$transclude` - A transclude linking function pre-bound to the correct transclusion scope.
   The scope can be overridden by an optional first argument.
  `function([scope], cloneLinkingFn)`.


#### `require`
Require another directive and inject its controller as the fourth argument to the linking function. The
`require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the
injected argument will be an array in corresponding order. If no such directive can be
found, or if the directive does not have a controller, then an error is raised. The name can be prefixed with:

* (no prefix) - Locate the required controller on the current element. Throw an error if not found.
* `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.
* `^` - Locate the required controller by searching the element's parents. Throw an error if not found.
* `?^` - Attempt to locate the required controller by searching the element's parents or pass `null` to the
  `link` fn if not found.


#### `controllerAs`
Controller alias at the directive scope. An alias for the controller so it
can be referenced at the directive template. The directive needs to define a scope for this
configuration to be used. Useful in the case when directive is used as component.


#### `restrict`
String of subset of `EACM` which restricts the directive to a specific directive
declaration style. If omitted, the default (attributes only) is used.

* `E` - Element name: `<my-directive></my-directive>`
* `A` - Attribute (default): `<div my-directive="exp"></div>`
* `C` - Class: `<div class="my-directive: exp;"></div>`
* `M` - Comment: `<!-- directive: my-directive exp -->`


#### `template`
replace the current element with the contents of the HTML. The replacement process
migrates all of the attributes / classes from the old element to the new one. See the
Directives Guide for an example.

You can specify `template` as a string representing the template or as a function which takes
two arguments `tElement` and `tAttrs` (described in the `compile` function api below) and
returns a string value representing the template.


#### `templateUrl`
Same as `template` but the template is loaded from the specified URL. Because
the template loading is asynchronous the compilation/linking is suspended until the template
is loaded.

You can specify `templateUrl` as a string representing the URL or as a function which takes two
arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns
a string value representing the url.  In either case, the template URL is passed through $sce.getTrustedResourceUrl.


#### `replace`
specify where the template should be inserted. Defaults to `false`.

* `true` - the template will replace the current element.
* `false` - the template will replace the contents of the current element.


#### `transclude`
compile the content of the element and make it available to the directive.
Typically used with ngTransclude. The advantage of transclusion is that the linking function receives a
transclusion function which is pre-bound to the correct scope. In a typical setup the widget
creates an `isolate` scope, but the transclusion is not a child, but a sibling of the `isolate`
scope. This makes it possible for the widget to have private state, and the transclusion to
be bound to the parent (pre-`isolate`) scope.

* `true` - transclude the content of the directive.
* `'element'` - transclude the whole element including any directives defined at lower priority.


#### `compile`

```js
  function compile(tElement, tAttrs, transclude) { ... }
```

The compile function deals with transforming the template DOM. Since most directives do not do
template transformation, it is not used often. Examples that require compile functions are
directives that transform template DOM, such as ngRepeat, or load the contents
asynchronously, such as ngView. The
compile function takes the following arguments.

  * `tElement` - template element - The element where the directive has been declared. It is
    safe to do template transformation on the element and child elements only.

  * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared
    between all directive compile functions.

  * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`

<div class="alert alert-warning">
**Note:** The template instance and the link instance may be different objects if the template has
been cloned. For this reason it is **not** safe to do anything other than DOM transformations that
apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration
should be done in a linking function rather than in a compile function.
</div>

<div class="alert alert-error">
**Note:** The `transclude` function that is passed to the compile function is deprecated, as it
  e.g. does not know about the right outer scope. Please use the transclude function that is passed
  to the link function instead.
</div>
A compile function can have a return value which can be either a function or an object.

* returning a (post-link) function - is equivalent to registering the linking function via the
  `link` property of the config object when the compile function is empty.

* returning an object with function(s) registered via `pre` and `post` properties - allows you to
  control when a linking function should be called during the linking phase. See info about
  pre-linking and post-linking functions below.


#### `link`
This property is used only if the `compile` property is not defined.

```js
  function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }
```

The link function is responsible for registering DOM listeners as well as updating the DOM. It is
executed after the template has been cloned. This is where most of the directive logic will be
put.

  * `scope` - Scope - The scope to be used by the
    directive for registering watches.

  * `iElement` - instance element - The element where the directive is to be used. It is safe to
    manipulate the children of the element only in `postLink` function since the children have
    already been linked.

  * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared
    between all directive linking functions.

  * `controller` - a controller instance - A controller instance if at least one directive on the
    element defines a controller. The controller is shared among all the directives, which allows
    the directives to use the controllers as a communication channel.

  * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.
    The scope can be overridden by an optional first argument. This is the same as the `$transclude`
    parameter of directive controllers.
    `function([scope], cloneLinkingFn)`.


#### Pre-linking function

Executed before the child elements are linked. Not safe to do DOM transformation since the
compiler linking function will fail to locate the correct elements for linking.

#### Post-linking function

Executed after the child elements are linked. It is safe to do DOM transformation in the post-linking function.

<a name="Attributes"></a>
### Attributes

The Attributes object - passed as a parameter in the
`link()` or `compile()` functions. It has a variety of uses.

accessing *Normalized attribute names:*
Directives like 'ngBind' can be expressed in many ways: 'ng:bind', `data-ng-bind`, or 'x-ng-bind'.
the attributes object allows for normalized access to
  the attributes.

* *Directive inter-communication:* All directives share the same instance of the attributes
  object which allows the directives to use the attributes object as inter directive
  communication.

* *Supports interpolation:* Interpolation attributes are assigned to the attribute object
  allowing other directives to read the interpolated value.

* *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes
  that contain interpolation (e.g. `src="{{bar}}"`). Not only is this very efficient but it's also
  the only way to easily get the actual value because during the linking phase the interpolation
  hasn't been evaluated yet and so the value is at this time set to `undefined`.

```js
function linkingFn(scope, elm, attrs, ctrl) {
  // get the attribute value
  console.log(attrs.ngModel);

  // change the attribute
  attrs.$set('ngModel', 'new value');

  // observe changes to interpolated attribute
  attrs.$observe('ngModel', function(value) {
    console.log('ngModel has changed value to ' + value);
  });
}
```

Below is an example using `$compileProvider`.

<div class="alert alert-warning">
**Note**: Typically directives are registered with `module.directive`. The example below is
to illustrate how `$compile` works.
</div>

 <example module="compile">
   <file name="index.html">
    <script>
      angular.module('compile', [], function($compileProvider) {
        // configure new 'compile' directive by passing a directive
        // factory function. The factory function injects the '$compile'
        $compileProvider.directive('compile', function($compile) {
          // directive factory creates a link function
          return function(scope, element, attrs) {
            scope.$watch(
              function(scope) {
                 // watch the 'compile' expression for changes
                return scope.$eval(attrs.compile);
              },
              function(value) {
                // when the 'compile' expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don't get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
              }
            );
          };
        })
      });

      function Ctrl($scope) {
        $scope.name = 'Angular';
        $scope.html = 'Hello {{name}}';
      }
    </script>
    <div ng-controller="Ctrl">
      <input ng-model="name"> <br>
      <textarea ng-model="html"></textarea> <br>
      <div compile="html"></div>
    </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should auto compile', function() {
       var textarea = $('textarea');
       var output = $('div[compile]');
       // The initial state reads 'Hello Angular'.
       expect(output.getText()).toBe('Hello Angular');
       textarea.clear();
       textarea.sendKeys('{{name}}!');
       expect(output.getText()).toBe('Angular!');
     });
   </file>
 </example>
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>element</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">DOMElement</span>


            
            </td>

            

            

            <td class="description last">Element or HTML string to compile into a template function.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code></code></td>
            

            <td class="type">
            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>maxPriority</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="global.html#number">number</a></span>


            
            </td>

            

            

            <td class="description last">only apply directives lower then given priority (Only effects the
                root element(s), not their children)</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line4768">line 4768</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            


        

    
</dd>

        
            
<dt>
    <h4 class="name" id="$compileProvider"><span class="type-signature"></span>$compileProvider<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line5240">line 5240</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$filter"><span class="type-signature"></span>$filter<span class="signature">(name)</span><span class="type-signature"> &rarr; {function}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Filters are used for formatting data displayed to the user.

The general syntax in templates is as follows:

        {{ expression [| filter_name[:parameter_value] ... ] }}
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>name</code></td>
            

            <td class="type">
            
                
<span class="param-type">String</span>


            
            </td>

            

            

            <td class="description last">Name of the filter function to retrieve</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line13865">line 13865</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    the filter function
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="$http"><span class="type-signature"></span>$http<span class="signature">(config)</span><span class="type-signature"> &rarr; {HttpPromise}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        The `$http` service is a core Angular service that facilitates communication with the remote
HTTP servers via the browser's [XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)
object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).

For unit testing applications that use `$http` service, see
$httpBackend mock.

For a higher level of abstraction, please check out the $resource service.

The $http API is based on the deferred/promise APIs exposed by
the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
it is important to familiarize yourself with these APIs and the guarantees they provide.


# General usage
The `$http` service is a function which takes a single argument — a configuration object —
that is used to generate an HTTP request and returns  a promise
with two $http specific methods: `success` and `error`.

```js
  $http({method: 'GET', url: '/someUrl'}).
    success(function(data, status, headers, config) {
      // this callback will be called asynchronously
      // when the response is available
    }).
    error(function(data, status, headers, config) {
      // called asynchronously if an error occurs
      // or server returns response with an error status.
    });
```

Since the returned value of calling the $http function is a `promise`, you can also use
the `then` method to register callbacks, and these callbacks will receive a single argument –
an object representing the response. See the API signature and type info below for more
details.

A response status code between 200 and 299 is considered a success status and
will result in the success callback being called. Note that if the response is a redirect,
XMLHttpRequest will transparently follow it, meaning that the error callback will not be
called for such responses.

# Writing Unit Tests that use $http
When unit testing (using ngMock), it is necessary to call
$httpBackend.flush() to flush each pending
request using trained responses.

```
$httpBackend.expectGET(...);
$http.get(...);
$httpBackend.flush();
```

# Shortcut methods

Since all invocations of the $http service require passing in an HTTP method and URL, and
POST/PUT requests require request data to be provided as well, shortcut methods
were created:

```js
  $http.get('/someUrl').success(successCallback);
  $http.post('/someUrl', data).success(successCallback);
```

Complete list of shortcut methods:

- $http.get
- {@link ng.$http#methods_head $http.head}
- $http.post
- {@link ng.$http#methods_put $http.put}
- $http.delete
- {@link ng.$http#methods_jsonp $http.jsonp}


# Setting HTTP Headers

The $http service will automatically add certain HTTP headers to all requests. These defaults
can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
object, which currently contains this default configuration:

- `$httpProvider.defaults.headers.common` (headers that are common for all requests):
  - `Accept: application/json, text/plain, * / *`
- `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
  - `Content-Type: application/json`
- `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
  - `Content-Type: application/json`

To add or overwrite these defaults, simply add or remove a property from these configuration
objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
with the lowercased HTTP method name as the key, e.g.
`$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }.

The defaults can also be set at runtime via the `$http.defaults` object in the same
fashion. For example:

```
module.run(function($http) {
  $http.defaults.headers.common.Authentication = 'Basic YmVlcDpib29w'
});
```

In addition, you can supply a `headers` property in the config object passed when
calling `$http(config)`, which overrides the defaults without changing them globally.


# Transforming Requests and Responses

Both requests and responses can be transformed using transform functions. By default, Angular
applies these transformations:

Request transformations:

- If the `data` property of the request configuration object contains an object, serialize it
  into JSON format.

Response transformations:

 - If XSRF prefix is detected, strip it (see Security Considerations section below).
 - If JSON response is detected, deserialize it using a JSON parser.

To globally augment or override the default transforms, modify the
`$httpProvider.defaults.transformRequest` and `$httpProvider.defaults.transformResponse`
properties. These properties are by default an array of transform functions, which allows you
to `push` or `unshift` a new transformation function into the transformation chain. You can
also decide to completely override any default transformations by assigning your
transformation functions to these properties directly without the array wrapper.  These defaults
are again available on the $http factory at run-time, which may be useful if you have run-time
services you wish to be involved in your transformations.

Similarly, to locally override the request/response transforms, augment the
`transformRequest` and/or `transformResponse` properties of the configuration object passed
into `$http`.


# Caching

To enable caching, set the request configuration `cache` property to `true` (to use default
cache) or to a custom cache object (built with `$cacheFactory`).
When the cache is enabled, `$http` stores the response from the server in the specified
cache. The next time the same request is made, the response is served from the cache without
sending a request to the server.

Note that even if the response is served from cache, delivery of the data is asynchronous in
the same way that real requests are.

If there are multiple GET requests for the same URL that should be cached using the same
cache, but the cache is not populated yet, only one request to the server will be made and
the remaining requests will be fulfilled using the response from the first request.

You can change the default cache to a new object (built with
`$cacheFactory`) by updating the
{@link ng.$http#properties_defaults `$http.defaults.cache`} property. All requests who set
their `cache` property to `true` will now use this cache object.

If you set the default cache to `false` then only requests that specify their own custom
cache object will be cached.

# Interceptors

Before you start creating interceptors, be sure to understand the
$q and deferred/promise APIs.

For purposes of global error handling, authentication, or any kind of synchronous or
asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
able to intercept requests before they are handed to the server and
responses before they are handed over to the application code that
initiated these requests. The interceptors leverage the promise APIs to fulfill this need for both synchronous and asynchronous pre-processing.

The interceptors are service factories that are registered with the `$httpProvider` by
adding them to the `$httpProvider.interceptors` array. The factory is called and
injected with dependencies (if specified) and returns the interceptor.

There are two kinds of interceptors (and two kinds of rejection interceptors):

  * `request`: interceptors get called with http `config` object. The function is free to
    modify the `config` or create a new one. The function needs to return the `config`
    directly or as a promise.
  * `requestError`: interceptor gets called when a previous interceptor threw an error or
    resolved with a rejection.
  * `response`: interceptors get called with http `response` object. The function is free to
    modify the `response` or create a new one. The function needs to return the `response`
    directly or as a promise.
  * `responseError`: interceptor gets called when a previous interceptor threw an error or
    resolved with a rejection.


```js
  // register the interceptor as a service
  $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
    return {
      // optional method
      'request': function(config) {
        // do something on success
        return config || $q.when(config);
      },

      // optional method
     'requestError': function(rejection) {
        // do something on error
        if (canRecover(rejection)) {
          return responseOrNewPromise
        }
        return $q.reject(rejection);
      },



      // optional method
      'response': function(response) {
        // do something on success
        return response || $q.when(response);
      },

      // optional method
     'responseError': function(rejection) {
        // do something on error
        if (canRecover(rejection)) {
          return responseOrNewPromise
        }
        return $q.reject(rejection);
      }
    };
  });

  $httpProvider.interceptors.push('myHttpInterceptor');


  // alternatively, register the interceptor via an anonymous factory
  $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
    return {
     'request': function(config) {
         // same as above
      },

      'response': function(response) {
         // same as above
      }
    };
  });
```

# Response interceptors (DEPRECATED)

Before you start creating interceptors, be sure to understand the
$q and deferred/promise APIs.

For purposes of global error handling, authentication or any kind of synchronous or
asynchronous preprocessing of received responses, it is desirable to be able to intercept
responses for http requests before they are handed over to the application code that
initiated these requests. The response interceptors leverage the promise apis to fulfil this need for both synchronous and asynchronous preprocessing.

The interceptors are service factories that are registered with the $httpProvider by
adding them to the `$httpProvider.responseInterceptors` array. The factory is called and
injected with dependencies (if specified) and returns the interceptor  — a function that
takes a promise and returns the original or a new promise.

```js
  // register the interceptor as a service
  $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
    return function(promise) {
      return promise.then(function(response) {
        // do something on success
        return response;
      }, function(response) {
        // do something on error
        if (canRecover(response)) {
          return responseOrNewPromise
        }
        return $q.reject(response);
      });
    }
  });

  $httpProvider.responseInterceptors.push('myHttpInterceptor');


  // register the interceptor via an anonymous factory
  $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {
    return function(promise) {
      // same as above
    }
  });
```


# Security Considerations

When designing web applications, consider security threats from:

- [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
- [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)

Both server and the client must cooperate in order to eliminate these threats. Angular comes
pre-configured with strategies that address these issues, but for this to work backend server
cooperation is required.

## JSON Vulnerability Protection

A [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)
allows third party website to turn your JSON resource URL into
[JSONP](http://en.wikipedia.org/wiki/JSONP) request under some conditions. To
counter this your server can prefix all JSON requests with following string `")]}',\n"`.
Angular will automatically strip the prefix before processing it as JSON.

For example if your server needs to return:
```js
['one','two']
```

which is vulnerable to attack, your server can return:
```js
)]}',
['one','two']
```

Angular will strip the prefix, before processing the JSON.


## Cross Site Request Forgery (XSRF) Protection

[XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) is a technique by which
an unauthorized site can gain your user's private data. Angular provides a mechanism
to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
(by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
JavaScript that runs on your domain could read the cookie, your server can be assured that
the XHR came from JavaScript running on your domain. The header will not be set for
cross-domain requests.

To take advantage of this, your server needs to set a token in a JavaScript readable session
cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
that only JavaScript running on your domain could have sent the request. The token must be
unique for each user and must be verifiable by the server (to prevent the JavaScript from
making up its own tokens). We recommend that the token is a digest of your site's
authentication cookie with a [salt](https://en.wikipedia.org/wiki/Salt_(cryptography))
for added security.

The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
properties of either $httpProvider.defaults at config-time, $http.defaults at run-time,
or the per-request config object.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>config</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last">Object describing the request to be made and how it should be
   processed. The object has following properties:

   - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)
   - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.
   - **params** – `{Object.<string|Object>}` – Map of strings or objects which will be turned
     to `?key1=value1&key2=value2` after the url. If the value is not a string, it will be
     JSONified.
   - **data** – `{string|Object}` – Data to be sent as the request message data.
   - **headers** – `{Object}` – Map of strings or functions which return strings representing
     HTTP headers to send to the server. If the return value of a function is null, the
     header will not be sent.
   - **xsrfHeaderName** – `{string}` – Name of HTTP header to populate with the XSRF token.
   - **xsrfCookieName** – `{string}` – Name of cookie containing the XSRF token.
   - **transformRequest** –
     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
     transform function or an array of such functions. The transform function takes the http
     request body and headers and returns its transformed (typically serialized) version.
   - **transformResponse** –
     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
     transform function or an array of such functions. The transform function takes the http
     response body and headers and returns its transformed (typically deserialized) version.
   - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the
     GET request, otherwise if a cache instance built with
     $cacheFactory, this cache will be used for
     caching.
   - **timeout** – `{number|Promise}` – timeout in milliseconds, or promise
     that should abort the request when resolved.
   - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the
     XHR object. See [requests with credentials]https://developer.mozilla.org/en/http_access_control#section_5
     for more information.
   - **responseType** - `{string}` - see
     [requestType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType).</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

        <h5 class="subsection-title">Properties:</h5>

        <dl>

<table class="props">
    <thead>
    <tr>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            

            <td class="type">
            
            </td>

            

            

            <td class="description last"></td>
        </tr>

    
    </tbody>
</table></dl>

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line7095">line 7095</a>
    </li></ul></dd>
    

    

    

    
</dl>


    
    <h5>Requires:</h5>
    <ul>
        <li>module:ng.$httpBackend</li>
    
        <li>module:$cacheFactory</li>
    
        <li>module:$rootScope</li>
    
        <li>module:$q</li>
    
        <li>module:$injector</li>
    </ul>
    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Returns a promise object with the
  standard `then` method and two http specific methods: `success` and `error`. The `then`
  method takes two arguments a success and an error callback which will be called with a
  response object. The `success` and `error` methods take a single argument - a function that
  will be called when the request succeeds or fails respectively. The arguments passed into
  these functions are destructured representation of the response object passed into the
  `then` method. The response object has these properties:

  - **data** – `{string|Object}` – The response body transformed with the transform
    functions.
  - **status** – `{number}` – HTTP status code of the response.
  - **headers** – `{function([headerName])}` – Header getter function.
  - **config** – `{Object}` – The configuration object that was used to generate the request.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">HttpPromise</span>


    </dd>
</dl>

        

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
&lt;file name="index.html">
  &lt;div ng-controller="FetchCtrl">
    &lt;select ng-model="method">
      &lt;option>GET&lt;/option>
      &lt;option>JSONP&lt;/option>
    &lt;/select>
    &lt;input type="text" ng-model="url" size="80"/>
    &lt;button id="fetchbtn" ng-click="fetch()">fetch&lt;/button>&lt;br>
    &lt;button id="samplegetbtn" ng-click="updateModel('GET', 'http-hello.html')">Sample GET&lt;/button>
    &lt;button id="samplejsonpbtn"
      ng-click="updateModel('JSONP',
                    'http://angularjs.org/greet.php?callback=JSON_CALLBACK&amp;name=Super%20Hero')">
      Sample JSONP
    &lt;/button>
    &lt;button id="invalidjsonpbtn"
      ng-click="updateModel('JSONP', 'http://angularjs.org/doesntexist&amp;callback=JSON_CALLBACK')">
        Invalid JSONP
      &lt;/button>
    &lt;pre>http status code: {{status}}&lt;/pre>
    &lt;pre>http response data: {{data}}&lt;/pre>
  &lt;/div>
&lt;/file>
&lt;file name="script.js">
  function FetchCtrl($scope, $http, $templateCache) {
    $scope.method = 'GET';
    $scope.url = 'http-hello.html';

    $scope.fetch = function() {
      $scope.code = null;
      $scope.response = null;

      $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
        success(function(data, status) {
          $scope.status = status;
          $scope.data = data;
        }).
        error(function(data, status) {
          $scope.data = data || "Request failed";
          $scope.status = status;
      });
    };

    $scope.updateModel = function(method, url) {
      $scope.method = method;
      $scope.url = url;
    };
  }
&lt;/file>
&lt;file name="http-hello.html">
  Hello, $http!
&lt;/file>
&lt;file name="protractor.js" type="protractor">
  var status = element(by.binding('status'));
  var data = element(by.binding('data'));
  var fetchBtn = element(by.id('fetchbtn'));
  var sampleGetBtn = element(by.id('samplegetbtn'));
  var sampleJsonpBtn = element(by.id('samplejsonpbtn'));
  var invalidJsonpBtn = element(by.id('invalidjsonpbtn'));

  it('should make an xhr GET request', function() {
    sampleGetBtn.click();
    fetchBtn.click();
    expect(status.getText()).toMatch('200');
    expect(data.getText()).toMatch(/Hello, \$http!/);
  });

  it('should make a JSONP request to angularjs.org', function() {
    sampleJsonpBtn.click();
    fetchBtn.click();
    expect(status.getText()).toMatch('200');
    expect(data.getText()).toMatch(/Super Hero!/);
  });

  it('should make JSONP request to invalid URL and invoke the error handler',
      function() {
    invalidJsonpBtn.click();
    fetchBtn.click();
    expect(status.getText()).toMatch('0');
    expect(data.getText()).toMatch('Request failed');
  });
&lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="$injector"><span class="type-signature"></span>$injector<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        `$injector` is used to retrieve object instances as defined by
provider, instantiate types, invoke methods,
and load modules.

The following always holds true:

```js
  var $injector = angular.injector();
  expect($injector.get('$injector')).toBe($injector);
  expect($injector.invoke(function($injector){
    return $injector;
  }).toBe($injector);
```

# Injection Function Annotation

JavaScript does not have annotations, and annotations are needed for dependency injection. The
following are all valid ways of annotating function with injection arguments and are equivalent.

```js
  // inferred (only works if code not minified/obfuscated)
  $injector.invoke(function(serviceA){});

  // annotated
  function explicit(serviceA) {};
  explicit.$inject = ['serviceA'];
  $injector.invoke(explicit);

  // inline
  $injector.invoke(['serviceA', function(serviceA){}]);
```

## Inference

In JavaScript calling `toString()` on a function returns the function definition. The definition
can then be parsed and the function arguments can be extracted. *NOTE:* This does not work with
minification, and obfuscation tools since these tools change the argument names.

## `$inject` Annotation
By adding a `$inject` property onto a function the injection parameters can be specified.

## Inline
As an array of injection names, where the last item in the array is the function to call.
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line3083">line 3083</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$interpolate"><span class="type-signature"></span>$interpolate<span class="signature">(text, <span class="optional">mustHaveExpression</span>, <span class="optional">trustedContext</span>)</span><span class="type-signature"> &rarr; {function}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Compiles a string with markup into an interpolation function. This service is used by the
HTML $compile service for data binding. See
$interpolateProvider for configuring the
interpolation markup.


       ```js
         var $interpolate = ...; // injected
         var exp = $interpolate('Hello {{name | uppercase}}!');
         expect(exp({name:'Angular'}).toEqual('Hello ANGULAR!');
       ```
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>text</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">The text with markup to interpolate.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>mustHaveExpression</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">if set to true then the interpolation string must have
   embedded expression in order to return an interpolation function. Strings with no
   embedded expression will return null for the interpolation function.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>trustedContext</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">when provided, the returned function passes the interpolated
   result through $sce.getTrusted(interpolatedResult,    trustedContext) before returning it.  Refer to the $sce service that
   provides Strict Contextual Escaping for details.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line8227">line 8227</a>
    </li></ul></dd>
    

    

    

    
</dl>


    
    <h5>Requires:</h5>
    <ul>
        <li>module:$parse</li>
    
        <li>module:$sce</li>
    </ul>
    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    an interpolation function which is used to compute the
   interpolated string. The function has these parameters:

   * `context`: an object against which any expressions embedded in the strings are evaluated
     against.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="$interpolateProvider"><span class="type-signature"></span>$interpolateProvider<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line8146">line 8146</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="customInterpolationApp">
&lt;file name="index.html">
&lt;script>
  var customInterpolationApp = angular.module('customInterpolationApp', []);

  customInterpolationApp.config(function($interpolateProvider) {
    $interpolateProvider.startSymbol('//');
    $interpolateProvider.endSymbol('//');
  });


  customInterpolationApp.controller('DemoController', function DemoController() {
      this.label = "This binding is brought you by // interpolation symbols.";
  });
&lt;/script>
&lt;div ng-app="App" ng-controller="DemoController as demo">
    //demo.label//
&lt;/div>
&lt;/file>
&lt;file name="protractor.js" type="protractor">
  it('should interpolate binding with custom symbols', function() {
    expect(element(by.binding('demo.label')).getText()).toBe('This binding is brought you by // interpolation symbols.');
  });
&lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="$parse"><span class="type-signature"></span>$parse<span class="signature">(expression)</span><span class="type-signature"> &rarr; {function}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Converts Angular expression into a function.

```js
  var getter = $parse('user.name');
  var setter = getter.assign;
  var context = {user:{name:'angular'}};
  var locals = {user:{name:'local'}};

  expect(getter(context)).toEqual('angular');
  setter(context, 'newValue');
  expect(context.user.name).toEqual('newValue');
  expect(getter(context, locals)).toEqual('local');
```
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>expression</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last">String expression to compile.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line10570">line 10570</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    a function which represents the compiled expression:

   * `context` – `{object}` – an object against which any expressions embedded in the strings
     are evaluated against (typically a scope object).
   * `locals` – `{object=}` – local variables context object, useful for overriding values in
     `context`.

   The returned function also has the following properties:
     * `literal` – `{boolean}` – whether the expression's top-level node is a JavaScript
       literal.
     * `constant` – `{boolean}` – whether the expression is made entirely of JavaScript
       constant literals.
     * `assign` – `{?function(context, value)}` – if the expression is assignable, this will be
       set to a function to change its value on the given context.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="$parseProvider"><span class="type-signature"></span>$parseProvider<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        `$parseProvider` can be used for configuring the default behavior of the $parse
 service.
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line10611">line 10611</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<dt>
    <h4 class="name" id="$sce"><span class="type-signature"></span>$sce<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.

# Strict Contextual Escaping

Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain
contexts to result in a value that is marked as safe to use for that context.  One example of
such a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer
to these contexts as privileged or SCE contexts.

As of version 1.2, Angular ships with SCE enabled by default.

Note:  When enabled (the default), IE8 in quirks mode is not supported.  In this mode, IE8 allows
one to execute arbitrary javascript by the use of the expression() syntax.  Refer
<http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.
You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`
to the top of your HTML document.

SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for
security vulnerabilities such as XSS, clickjacking, etc. a lot easier.

Here's an example of a binding in a privileged context:

<pre class="prettyprint">
    <input ng-model="userHtml">
    <div ng-bind-html="userHtml">
</pre>

Notice that `ng-bind-html` is bound to `userHtml` controlled by the user.  With SCE
disabled, this application allows the user to render arbitrary HTML into the DIV.
In a more realistic example, one may be rendering user comments, blog articles, etc. via
bindings.  (HTML is just one example of a context where rendering user controlled input creates
security vulnerabilities.)

For the case of HTML, you might use a library, either on the client side, or on the server side,
to sanitize unsafe HTML before binding to the value and rendering it in the document.

How would you ensure that every place that used these types of bindings was bound to a value that
was sanitized by your library (or returned as safe for rendering by your server?)  How can you
ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
properties/fields and forgot to update the binding to the sanitized value?

To be secure by default, you want to ensure that any such bindings are disallowed unless you can
determine that something explicitly says it's safe to use a value for binding in that
context.  You can then audit your code (a simple grep would do) to ensure that this is only done
for those values that you can easily tell are safe - because they were received from your server,
sanitized by your library, etc.  You can organize your codebase to help with this - perhaps
allowing only the files in a specific directory to do this.  Ensuring that the internal API
exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.

In the case of AngularJS' SCE service, one uses $sce.trustAs
(and shorthand methods such as $sce.trustAsHtml, etc.) to
obtain values that will be accepted by SCE / privileged contexts.


## How does it work?

In privileged contexts, directives and code will bind to the result of $sce.getTrusted(context, value) rather than to the value directly.  Directives use $sce.parseAs rather than `$parse` to watch attribute bindings, which performs the
$sce.getTrusted behind the scenes on non-constant literals.

As an example, ngBindHtml uses {@link
ng.$sce#methods_parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly
simplified):

<pre class="prettyprint">
  var ngBindHtmlDirective = ['$sce', function($sce) {
    return function(scope, element, attr) {
      scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {
        element.html(value || '');
      });
    };
  }];
</pre>

## Impact on loading templates

This applies both to the `ng-include` directive as well as
`templateUrl`'s specified by directives.

By default, Angular only loads templates from the same domain and protocol as the application
document.  This is done by calling $sce.getTrustedResourceUrl on the template URL.  To load templates from other domains and/or
protocols, you may either either whitelist them or {@link ng.$sce#methods_trustAsResourceUrl wrap it} into a trusted value.

*Please note*:
The browser's
[Same Origin Policy](https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest)
and [Cross-Origin Resource Sharing (CORS)](http://www.w3.org/TR/cors/)
policy apply in addition to this and may further restrict whether the template is successfully
loaded.  This means that without the right CORS policy, loading templates from a different domain
won't work on all browsers.  Also, loading templates from `file://` URL does not work on some
browsers.

## This feels like too much overhead for the developer?

It's important to remember that SCE only applies to interpolation expressions.

If your expressions are constant literals, they're automatically trusted and you don't need to
call `$sce.trustAs` on them (remember to include the `ngSanitize` module) (e.g.
`<div ng-bind-html="'<b>implicitly trusted</b>'"></div>`) just works.

Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them
through $sce.getTrusted.  SCE doesn't play a role here.

The included $sceDelegate comes with sane defaults to allow you to load
templates in `ng-include` from your application's domain without having to even know about SCE.
It blocks loading templates from other domains or loading templates over http from an https
served document.  You can change these by setting your own custom whitelists and {@link
ng.$sceDelegateProvider#methods_resourceUrlBlacklist blacklists} for matching such URLs.

This significantly reduces the overhead.  It is far easier to pay the small overhead and have an
application that's secure and can be audited to verify that with much more ease than bolting
security onto an application later.

<a name="contexts"></a>
## What trusted context types are supported?

| Context             | Notes          |
|---------------------|----------------|
| `$sce.HTML`         | For HTML that's safe to source into the application.  The ngBindHtml directive uses this context for bindings. |
| `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |
| `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't consititute an SCE context. |
| `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contens are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
| `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |

## Format of items in resourceUrlWhitelist/{@link ng.$sceDelegateProvider#methods_resourceUrlBlacklist Blacklist} <a name="resourceUrlPatternItem"></a>

 Each element in these arrays must be one of the following:

 - **'self'**
   - The special **string**, `'self'`, can be used to match against all URLs of the **same
     domain** as the application document using the **same protocol**.
 - **String** (except the special value `'self'`)
   - The string is matched against the full *normalized / absolute URL* of the resource
     being tested (substring matches are not good enough.)
   - There are exactly **two wildcard sequences** - `*` and `**`.  All other characters
     match themselves.
   - `*`: matches zero or more occurances of any character other than one of the following 6
     characters: '`:`', '`/`', '`.`', '`?`', '`&`' and ';'.  It's a useful wildcard for use
     in a whitelist.
   - `**`: matches zero or more occurances of *any* character.  As such, it's not
     not appropriate to use in for a scheme, domain, etc. as it would match too much.  (e.g.
     http://**.example.com/ would match http://evil.com/?ignore=.example.com/ and that might
     not have been the intention.)  It's usage at the very end of the path is ok.  (e.g.
     http://foo.example.com/templates/**).
 - **RegExp** (*see caveat below*)
   - *Caveat*:  While regular expressions are powerful and offer great flexibility,  their syntax
     (and all the inevitable escaping) makes them *harder to maintain*.  It's easy to
     accidentally introduce a bug when one updates a complex expression (imho, all regexes should
     have good test coverage.).  For instance, the use of `.` in the regex is correct only in a
     small number of cases.  A `.` character in the regex used when matching the scheme or a
     subdomain could be matched against a `:` or literal `.` that was likely not intended.   It
     is highly recommended to use the string patterns and only fall back to regular expressions
     if they as a last resort.
   - The regular expression must be an instance of RegExp (i.e. not a string.)  It is
     matched against the **entire** *normalized / absolute URL* of the resource being tested
     (even when the RegExp did not have the `^` and `$` codes.)  In addition, any flags
     present on the RegExp (such as multiline, global, ignoreCase) are ignored.
   - If you are generating your JavaScript from some other templating engine (not
     recommended, e.g. in issue [#4006](https://github.com/angular/angular.js/issues/4006)),
     remember to escape your regular expression (and be aware that you might need more than
     one level of escaping depending on your templating engine and the way you interpolated
     the value.)  Do make use of your platform's escaping mechanism as it might be good
     enough before coding your own.  e.g. Ruby has
     [Regexp.escape(str)](http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape)
     and Python has [re.escape](http://docs.python.org/library/re.html#re.escape).
     Javascript lacks a similar built in function for escaping.  Take a look at Google
     Closure library's [goog.string.regExpEscape(s)](
     http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962).

Refer $sceDelegateProvider for an example.

## Show me an example using SCE.
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line12817">line 12817</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example module="mySceApp" deps="angular-sanitize.js">
&lt;file name="index.html">
  &lt;div ng-controller="myAppController as myCtrl">
    &lt;i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml">&lt;/i>&lt;br>&lt;br>
    &lt;b>User comments&lt;/b>&lt;br>
    By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when
    $sanitize is available.  If $sanitize isn't available, this results in an error instead of an
    exploit.
    &lt;div class="well">
      &lt;div ng-repeat="userComment in myCtrl.userComments">
        &lt;b>{{userComment.name}}&lt;/b>:
        &lt;span ng-bind-html="userComment.htmlComment" class="htmlComment">&lt;/span>
        &lt;br>
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;/file>

&lt;file name="script.js">
  var mySceApp = angular.module('mySceApp', ['ngSanitize']);

  mySceApp.controller("myAppController", function myAppController($http, $templateCache, $sce) {
    var self = this;
    $http.get("test_data.json", {cache: $templateCache}).success(function(userComments) {
      self.userComments = userComments;
    });
    self.explicitlyTrustedHtml = $sce.trustAsHtml(
        '&lt;span onmouseover="this.textContent=&amp;quot;Explicitly trusted HTML bypasses ' +
        'sanitization.&amp;quot;">Hover over this text.&lt;/span>');
  });
&lt;/file>

&lt;file name="test_data.json">
[
  { "name": "Alice",
    "htmlComment":
        "&lt;span onmouseover='this.textContent=\"PWN3D!\"'>Is &lt;i>anyone&lt;/i> reading this?&lt;/span>"
  },
  { "name": "Bob",
    "htmlComment": "&lt;i>Yes!&lt;/i>  Am I the only other one?"
  }
]
&lt;/file>

&lt;file name="protractor.js" type="protractor">
  describe('SCE doc demo', function() {
    it('should sanitize untrusted values', function() {
      expect(element(by.css('.htmlComment')).getInnerHtml())
          .toBe('&lt;span>Is &lt;i>anyone&lt;/i> reading this?&lt;/span>');
    });

    it('should NOT sanitize explicitly trusted values', function() {
      expect(element(by.id('explicitlyTrustedHtml')).getInnerHtml()).toBe(
          '&lt;span onmouseover="this.textContent=&amp;quot;Explicitly trusted HTML bypasses ' +
          'sanitization.&amp;quot;">Hover over this text.&lt;/span>');
    });
  });
&lt;/file>
&lt;/example>



## Can I disable SCE completely?

Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits
for little coding overhead.  It will be much harder to take an SCE disabled application and
either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE
for cases where you have a lot of existing code that was written before SCE was introduced and
you're migrating them a module at a time.

That said, here's how you can completely disable SCE:

&lt;pre class="prettyprint">
  angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
    // Completely disable SCE.  For demonstration purposes only!
    // Do not use in new projects.
    $sceProvider.enabled(false);
  });
&lt;/pre></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="$sceDelegate"><span class="type-signature"></span>$sceDelegate<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        `$sceDelegate` is a service that is used by the `$sce` service to provide Strict Contextual Escaping (SCE) services to AngularJS.

Typically, you would configure or override the $sceDelegate instead of
the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
work because `$sce` delegates to `$sceDelegate` for these operations.

Refer $sceDelegateProvider to configure this service.

The default instance of `$sceDelegate` should work out of the box with little pain.  While you
can override it completely to change the behavior of `$sce`, the common case would
involve configuring the $sceDelegateProvider instead by setting
your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as
templates.  Refer $sceDelegateProvider.resourceUrlWhitelist and {@link
ng.$sceDelegateProvider#methods_resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line12489">line 12489</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<dt>
    <h4 class="name" id="currency"><span class="type-signature"></span>currency<span class="signature">(amount, <span class="optional">symbol</span>)</span><span class="type-signature"> &rarr; {string}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
symbol for current locale is used.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>amount</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="global.html#number">number</a></span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Input to filter.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>symbol</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Currency symbol or identifier to be displayed.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14154">line 14154</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Formatted number.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

        

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script>
      function Ctrl($scope) {
        $scope.amount = 1234.56;
      }
    &lt;/script>
    &lt;div ng-controller="Ctrl">
      &lt;input type="number" ng-model="amount"> &lt;br>
      default currency symbol ($): &lt;span id="currency-default">{{amount | currency}}&lt;/span>&lt;br>
      custom currency identifier (USD$): &lt;span>{{amount | currency:"USD$"}}&lt;/span>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should init with 1234.56', function() {
      expect(element(by.id('currency-default')).getText()).toBe('$1,234.56');
      expect(element(by.binding('amount | currency:"USD$"')).getText()).toBe('USD$1,234.56');
    });
    it('should update', function() {
      if (browser.params.browser == 'safari') {
        // Safari does not understand the minus key. See
        // https://github.com/angular/protractor/issues/481
        return;
      }
      element(by.model('amount')).clear();
      element(by.model('amount')).sendKeys('-1234');
      expect(element(by.id('currency-default')).getText()).toBe('($1,234.00)');
      expect(element(by.binding('amount | currency:"USD$"')).getText()).toBe('(USD$1,234.00)');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="date"><span class="type-signature"></span>date<span class="signature">(date, <span class="optional">format</span>)</span><span class="type-signature"> &rarr; {string}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Formats `date` to a string based on the requested `format`.

  `format` string can be composed of the following elements:

  * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
  * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
  * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
  * `'MMMM'`: Month in year (January-December)
  * `'MMM'`: Month in year (Jan-Dec)
  * `'MM'`: Month in year, padded (01-12)
  * `'M'`: Month in year (1-12)
  * `'dd'`: Day in month, padded (01-31)
  * `'d'`: Day in month (1-31)
  * `'EEEE'`: Day in Week,(Sunday-Saturday)
  * `'EEE'`: Day in Week, (Sun-Sat)
  * `'HH'`: Hour in day, padded (00-23)
  * `'H'`: Hour in day (0-23)
  * `'hh'`: Hour in am/pm, padded (01-12)
  * `'h'`: Hour in am/pm, (1-12)
  * `'mm'`: Minute in hour, padded (00-59)
  * `'m'`: Minute in hour (0-59)
  * `'ss'`: Second in minute, padded (00-59)
  * `'s'`: Second in minute (0-59)
  * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)
  * `'a'`: am/pm marker
  * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)

  `format` string can also be one of the following predefined
  localizable formats:

  * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
    (e.g. Sep 3, 2010 12:05:08 pm)
  * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)
  * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale
    (e.g. Friday, September 3, 2010)
  * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)
  * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
  * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
  * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)
  * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)

  `format` string can contain literal values. These need to be quoted with single quotes (e.g.
  `"h 'in the morning'"`). In order to output single quote, use two single quotes in a sequence
  (e.g. `"h 'o''clock'"`).
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>date</code></td>
            

            <td class="type">
            
                
<span class="param-type">Date</span>
|

<span class="param-type"><a href="global.html#number">number</a></span>
|

<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Date to format either as Date object, milliseconds (string or
   number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its
   shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
   specified in the string input, the time is considered to be in the local timezone.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>format</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Formatting rules (see Description). If not specified,
   `mediumDate` is used.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14423">line 14423</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Formatted string or the input if input is not recognized as date/millis.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

        

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;span ng-non-bindable>{{1288323623006 | date:'medium'}}&lt;/span>:
        &lt;span>{{1288323623006 | date:'medium'}}&lt;/span>&lt;br>
    &lt;span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}&lt;/span>:
       &lt;span>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}&lt;/span>&lt;br>
    &lt;span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}&lt;/span>:
       &lt;span>{{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}&lt;/span>&lt;br>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should format date', function() {
      expect(element(by.binding("1288323623006 | date:'medium'")).getText()).
         toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
      expect(element(by.binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).getText()).
         toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
      expect(element(by.binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).getText()).
         toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="filter"><span class="type-signature"></span>filter<span class="signature">(array, expression, comparator)</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Selects a subset of items from `array` and returns it as a new array.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>array</code></td>
            

            <td class="type">
            
                
<span class="param-type">Array</span>


            
            </td>

            

            

            <td class="description last">The source array.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>expression</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">Object</span>
|

<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last">The predicate to be used for selecting items from
  `array`.

  Can be one of:

  - `string`: The string is evaluated as an expression and the resulting value is used for substring match against
    the contents of the `array`. All strings or objects with string properties in `array` that contain this string
    will be returned. The predicate can be negated by prefixing the string with `!`.

  - `Object`: A pattern object can be used to filter specific properties on objects contained
    by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
    which have property `name` containing "M" and property `phone` containing "1". A special
    property name `$` can be used (as in `{$:"text"}`) to accept a match against any
    property of the object. That's equivalent to the simple substring match with a `string`
    as described above.

  - `function(value)`: A predicate function can be used to write arbitrary filters. The function is
    called for each element of `array`. The final result is an array of those elements that
    the predicate returned true for.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>comparator</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>
|

<span class="param-type">true</span>
|

<span class="param-type">undefined</span>


            
            </td>

            

            

            <td class="description last">Comparator which is used in
    determining if the expected value (from the filter expression) and actual value (from
    the object in the array) should be considered a match.

  Can be one of:

    - `function(actual, expected)`:
      The function will be given the object value and the predicate value to compare and
      should return true if the item should be included in filtered result.

    - `true`: A shorthand for `function(actual, expected) { return angular.equals(expected, actual)}`.
      this is essentially strict comparison of expected and actual.

    - `false|undefined`: A short hand for a function which will look for a substring match in case
      insensitive way.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line13935">line 13935</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;div ng-init="friends = [{name:'John', phone:'555-1276'},
                             {name:'Mary', phone:'800-BIG-MARY'},
                             {name:'Mike', phone:'555-4321'},
                             {name:'Adam', phone:'555-5678'},
                             {name:'Julie', phone:'555-8765'},
                             {name:'Juliette', phone:'555-5678'}]">&lt;/div>

    Search: &lt;input ng-model="searchText">
    &lt;table id="searchTextResults">
      &lt;tr>&lt;th>Name&lt;/th>&lt;th>Phone&lt;/th>&lt;/tr>
      &lt;tr ng-repeat="friend in friends | filter:searchText">
        &lt;td>{{friend.name}}&lt;/td>
        &lt;td>{{friend.phone}}&lt;/td>
      &lt;/tr>
    &lt;/table>
    &lt;hr>
    Any: &lt;input ng-model="search.$"> &lt;br>
    Name only &lt;input ng-model="search.name">&lt;br>
    Phone only &lt;input ng-model="search.phone">&lt;br>
    Equality &lt;input type="checkbox" ng-model="strict">&lt;br>
    &lt;table id="searchObjResults">
      &lt;tr>&lt;th>Name&lt;/th>&lt;th>Phone&lt;/th>&lt;/tr>
      &lt;tr ng-repeat="friendObj in friends | filter:search:strict">
        &lt;td>{{friendObj.name}}&lt;/td>
        &lt;td>{{friendObj.phone}}&lt;/td>
      &lt;/tr>
    &lt;/table>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var expectFriendNames = function(expectedNames, key) {
      element.all(by.repeater(key + ' in friends').column(key + '.name')).then(function(arr) {
        arr.forEach(function(wd, i) {
          expect(wd.getText()).toMatch(expectedNames[i]);
        });
      });
    };

    it('should search across all fields when filtering with a string', function() {
      var searchText = element(by.model('searchText'));
      searchText.clear();
      searchText.sendKeys('m');
      expectFriendNames(['Mary', 'Mike', 'Adam'], 'friend');

      searchText.clear();
      searchText.sendKeys('76');
      expectFriendNames(['John', 'Julie'], 'friend');
    });

    it('should search in specific fields when filtering with a predicate object', function() {
      var searchAny = element(by.model('search.$'));
      searchAny.clear();
      searchAny.sendKeys('i');
      expectFriendNames(['Mary', 'Mike', 'Julie', 'Juliette'], 'friendObj');
    });
    it('should use a equal comparison when comparator is true', function() {
      var searchName = element(by.model('search.name'));
      var strict = element(by.model('strict'));
      searchName.clear();
      searchName.sendKeys('Julie');
      strict.click();
      expectFriendNames(['Julie'], 'friendObj');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="json"><span class="type-signature"></span>json<span class="signature">(object)</span><span class="type-signature"> &rarr; {string}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Allows you to convert a JavaScript object into JSON string.

  This filter is mostly useful for debugging. When using the double curly {{value}} notation
  the binding is automatically converted to JSON.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>object</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Any JavaScript object (including arrays and primitive types) to filter.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14580">line 14580</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    JSON string.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="limitTo"><span class="type-signature"></span>limitTo<span class="signature">(input, limit)</span><span class="type-signature"> &rarr; {Array|string}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Creates a new array or string containing only a specified number of elements. The elements
are taken from either the beginning or the end of the source array or string, as specified by
the value and sign (positive or negative) of `limit`.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>input</code></td>
            

            <td class="type">
            
                
<span class="param-type">Array</span>
|

<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last">Source array or string to be limited.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>limit</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type"><a href="global.html#number">number</a></span>


            
            </td>

            

            

            <td class="description last">The length of the returned array or string. If the `limit` number
    is positive, `limit` number of items from the beginning of the source array/string are copied.
    If the number is negative, `limit` number  of items from the end of the source array/string
    are copied. The `limit` will be trimmed if it exceeds `array.length`</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14636">line 14636</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    A new sub-array or substring of length `limit` or less if input array
    had less than `limit` elements.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Array</span>
|

<span class="param-type">string</span>


    </dd>
</dl>

        

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script>
      function Ctrl($scope) {
        $scope.numbers = [1,2,3,4,5,6,7,8,9];
        $scope.letters = "abcdefghi";
        $scope.numLimit = 3;
        $scope.letterLimit = 3;
      }
    &lt;/script>
    &lt;div ng-controller="Ctrl">
      Limit {{numbers}} to: &lt;input type="integer" ng-model="numLimit">
      &lt;p>Output numbers: {{ numbers | limitTo:numLimit }}&lt;/p>
      Limit {{letters}} to: &lt;input type="integer" ng-model="letterLimit">
      &lt;p>Output letters: {{ letters | limitTo:letterLimit }}&lt;/p>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    var numLimitInput = element(by.model('numLimit'));
    var letterLimitInput = element(by.model('letterLimit'));
    var limitedNumbers = element(by.binding('numbers | limitTo:numLimit'));
    var limitedLetters = element(by.binding('letters | limitTo:letterLimit'));

    it('should limit the number array to first three items', function() {
      expect(numLimitInput.getAttribute('value')).toBe('3');
      expect(letterLimitInput.getAttribute('value')).toBe('3');
      expect(limitedNumbers.getText()).toEqual('Output numbers: [1,2,3]');
      expect(limitedLetters.getText()).toEqual('Output letters: abc');
    });

    it('should update the output when -3 is entered', function() {
      numLimitInput.clear();
      numLimitInput.sendKeys('-3');
      letterLimitInput.clear();
      letterLimitInput.sendKeys('-3');
      expect(limitedNumbers.getText()).toEqual('Output numbers: [7,8,9]');
      expect(limitedLetters.getText()).toEqual('Output letters: ghi');
    });

    it('should not exceed the maximum size of input array', function() {
      numLimitInput.clear();
      numLimitInput.sendKeys('100');
      letterLimitInput.clear();
      letterLimitInput.sendKeys('100');
      expect(limitedNumbers.getText()).toEqual('Output numbers: [1,2,3,4,5,6,7,8,9]');
      expect(limitedLetters.getText()).toEqual('Output letters: abcdefghi');
    });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="lowercase"><span class="type-signature"></span>lowercase<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Converts string to lowercase.
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14615">line 14615</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li>angular.lowercase</li>
        </ul>
    </dd>
    

    
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(element)</span><span class="type-signature"> &rarr; {Object}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.

If jQuery is available, `angular.element` is an alias for the
[jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not available, `angular.element`
delegates to Angular's built-in subset of jQuery, called "jQuery lite" or "jqLite."

<div class="alert alert-success">jqLite is a tiny, API-compatible subset of jQuery that allows
Angular to manipulate the DOM in a cross-browser compatible way. **jqLite** implements only the most
commonly needed functionality with the goal of having a very small footprint.</div>

To use jQuery, simply load it before `DOMContentLoaded` event fired.

<div class="alert">**Note:** all element references in Angular are always wrapped with jQuery or
jqLite; they are never raw DOM references.</div>

## Angular's jqLite
jqLite provides only the following jQuery methods:

- [`addClass()`](http://api.jquery.com/addClass/)
- [`after()`](http://api.jquery.com/after/)
- [`append()`](http://api.jquery.com/append/)
- [`attr()`](http://api.jquery.com/attr/)
- [`bind()`](http://api.jquery.com/bind/) - Does not support namespaces, selectors or eventData
- [`children()`](http://api.jquery.com/children/) - Does not support selectors
- [`clone()`](http://api.jquery.com/clone/)
- [`contents()`](http://api.jquery.com/contents/)
- [`css()`](http://api.jquery.com/css/)
- [`data()`](http://api.jquery.com/data/)
- [`empty()`](http://api.jquery.com/empty/)
- [`eq()`](http://api.jquery.com/eq/)
- [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag name
- [`hasClass()`](http://api.jquery.com/hasClass/)
- [`html()`](http://api.jquery.com/html/)
- [`next()`](http://api.jquery.com/next/) - Does not support selectors
- [`on()`](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
- [`off()`](http://api.jquery.com/off/) - Does not support namespaces or selectors
- [`one()`](http://api.jquery.com/one/) - Does not support namespaces or selectors
- [`parent()`](http://api.jquery.com/parent/) - Does not support selectors
- [`prepend()`](http://api.jquery.com/prepend/)
- [`prop()`](http://api.jquery.com/prop/)
- [`ready()`](http://api.jquery.com/ready/)
- [`remove()`](http://api.jquery.com/remove/)
- [`removeAttr()`](http://api.jquery.com/removeAttr/)
- [`removeClass()`](http://api.jquery.com/removeClass/)
- [`removeData()`](http://api.jquery.com/removeData/)
- [`replaceWith()`](http://api.jquery.com/replaceWith/)
- [`text()`](http://api.jquery.com/text/)
- [`toggleClass()`](http://api.jquery.com/toggleClass/)
- [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
- [`unbind()`](http://api.jquery.com/unbind/) - Does not support namespaces
- [`val()`](http://api.jquery.com/val/)
- [`wrap()`](http://api.jquery.com/wrap/)

## jQuery/jqLite Extras
Angular also provides the following additional methods and events to both jQuery and jqLite:

### Events
- `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event
   on all DOM nodes being removed.  This can be used to clean up any 3rd party bindings to the DOM
   element before it is removed.

### Methods
- `controller(name)` - retrieves the controller of the current element or its parent. By default
  retrieves controller associated with the `ngController` directive. If `name` is provided as
  camelCase directive name, then the controller for this directive will be retrieved (e.g.
  `'ngModel'`).
- `injector()` - retrieves the injector of the current element or its parent.
- `scope()` - retrieves the scope of the current
  element or its parent.
- `isolateScope()` - retrieves an isolate scope if one is attached directly to the
  current element. This getter should be used only on elements that contain a directive which starts a new isolate
  scope. Calling `scope()` on this element always returns the original non-isolate scope.
- `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
  parent element is reached.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>element</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">DOMElement</span>


            
            </td>

            

            

            <td class="description last">HTML string or DOMElement to be wrapped into jQuery.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line2019">line 2019</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    jQuery object.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Object</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(json)</span><span class="type-signature"> &rarr; {Object|Array|Date|string|<a href="global.html#number">number</a>}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Deserializes a JSON string.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>json</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last">JSON string to deserialize.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line1058">line 1058</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Deserialized thingy.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Object</span>
|

<span class="param-type">Array</span>
|

<span class="param-type">Date</span>
|

<span class="param-type">string</span>
|

<span class="param-type"><a href="global.html#number">number</a></span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(string)</span><span class="type-signature"> &rarr; {string}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Converts the specified string to uppercase.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>string</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last">String to be converted to uppercase.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line197">line 197</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Uppercased string.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(obj, <span class="optional">pretty</span>)</span><span class="type-signature"> &rarr; {string|undefined}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Serializes input into a JSON-formatted string. Properties with leading $ characters will be
stripped since angular uses this notation internally.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>obj</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>
|

<span class="param-type">Array</span>
|

<span class="param-type">Date</span>
|

<span class="param-type">string</span>
|

<span class="param-type"><a href="global.html#number">number</a></span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Input to be serialized into JSON.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>pretty</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">If set to true, the JSON output will contain newlines and whitespace.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line1038">line 1038</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    JSON-ified string representing `obj`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>
|

<span class="param-type">undefined</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(self, fn, args)</span><span class="type-signature"> &rarr; {function}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
`fn`). You can supply optional `args` that are prebound to the function. This feature is also
known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>self</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Context which `fn` should be evaluated in.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Function to be bound.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>args</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last">Optional arguments to be prebound to the `fn` function call.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line982">line 982</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Function that wraps the `fn` with all the specified bindings.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(o1, o2)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if two objects or two values are equivalent. Supports value types, regular
expressions, arrays and objects.

Two objects or values are considered equivalent if at least one of the following is true:

* Both objects or values pass `===` comparison.
* Both objects or values are of the same type and all of their properties are equal by
  comparing them with `angular.equals`.
* Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
* Both values represent the same regular expression (In JavasScript,
  /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
  representation matches).

During a property comparison, properties of `function` type and properties with names
that begin with `$` are ignored.

Scope and DOMWindow objects are being compared only by identify (`===`).
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>o1</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Object or value to compare.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>o2</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Object or value to compare.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line895">line 895</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if arguments are equal.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
considered to be objects.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line519">line 519</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is an `Object` but not `null`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(source, <span class="optional">destination</span>)</span><span class="type-signature"> &rarr; {*}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Creates a deep copy of `source`, which should be an object or an array.

* If no destination is supplied, a copy of the object or array is created.
* If a destination is provided, all of its elements (for array) or properties (for objects)
  are deleted and then all elements/properties from the source are copied to it.
* If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.
* If `source` is identical to 'destination' an exception will be thrown.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>source</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">The source that will be used to make a copy.
                  Can be any type, including primitives, `null`, and `undefined`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>destination</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>
|

<span class="param-type">Array</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Destination into which the source is copied. If
    provided, must be of the same type as `source`.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line779">line 779</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    The copy or updated `destination`, if `destination` was specified.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

        

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
&lt;file name="index.html">
&lt;div ng-controller="Controller">
&lt;form novalidate class="simple-form">
Name: &lt;input type="text" ng-model="user.name" />&lt;br />
E-mail: &lt;input type="email" ng-model="user.email" />&lt;br />
Gender: &lt;input type="radio" ng-model="user.gender" value="male" />male
&lt;input type="radio" ng-model="user.gender" value="female" />female&lt;br />
&lt;button ng-click="reset()">RESET&lt;/button>
&lt;button ng-click="update(user)">SAVE&lt;/button>
&lt;/form>
&lt;pre>form = {{user | json}}&lt;/pre>
&lt;pre>master = {{master | json}}&lt;/pre>
&lt;/div>

&lt;script>
function Controller($scope) {
   $scope.master= {};

   $scope.update = function(user) {
     // Example with 1 argument
     $scope.master= angular.copy(user);
   };

   $scope.reset = function() {
     // Example with 2 arguments
     angular.copy($scope.master, $scope.user);
   };

   $scope.reset();
 }
&lt;/script>
&lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(obj, iterator, <span class="optional">context</span>)</span><span class="type-signature"> &rarr; {Object|Array}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Invokes the `iterator` function once for each item in `obj` collection, which can be either an
object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`
is the value of an object property or an array element and `key` is the object property key or
array element index. Specifying a `context` for the function is optional.

It is worth noting that `.forEach` does not iterate over inherited properties because it filters
using the `hasOwnProperty` method.

   ```js
     var values = {name: 'misko', gender: 'male'};
     var log = [];
     angular.forEach(values, function(value, key){
       this.push(key + ': ' + value);
     }, log);
     expect(log).toEqual(['name: misko', 'gender: male']);
   ```
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>obj</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>
|

<span class="param-type">Array</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Object to iterate over.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iterator</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Iterator function.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>context</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Object to become context (`this`) for the iterator function.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line281">line 281</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Reference to `obj`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Object</span>
|

<span class="param-type">Array</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is a DOM element (or wrapped jQuery element).
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line668">line 668</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is a DOM element (or wrapped jQuery element).
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(dst, src)</span><span class="type-signature"> &rarr; {Object}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Extends the destination object `dst` by copying all of the properties from the `src` object(s)
to `dst`. You can specify multiple `src` objects.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>dst</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Destination object.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last">Source object(s).</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line410">line 410</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Reference to `dst`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Object</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        A function that performs no operations. This function can be useful when writing code in the
functional style.
   ```js
     function foo(callback) {
       var result = calculateResult();
       (callback || angular.noop)(result);
     }
   ```
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line447">line 447</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        A function that returns its first argument. This function is useful when writing code in the
functional style.

   ```js
     function transformer(transformationFn, value) {
       return (transformationFn || angular.identity)(value);
     };
   ```
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line467">line 467</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is undefined.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line489">line 489</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is undefined.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is defined.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line504">line 504</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is defined.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(string)</span><span class="type-signature"> &rarr; {string}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Converts the specified string to lowercase.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>string</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last">String to be converted to lowercase.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line184">line 184</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Lowercased string.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is a `String`.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line535">line 535</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is a `String`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is a `Number`.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line550">line 550</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is a `Number`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is a `Function`.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line599">line 599</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is a `Function`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a reference is an `Array`.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line582">line 582</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is an `Array`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="ng"><span class="type-signature"></span>ng<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Determines if a value is a date.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last">Reference to check.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line565">line 565</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    True if `value` is a `Date`.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

        

    
</dd>

        
            
<dt>
    <h4 class="name" id="number"><span class="type-signature"></span>number<span class="signature">(number, <span class="optional">fractionSize</span>)</span><span class="type-signature"> &rarr; {string}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Formats a number as text.

If the input is not a number an empty string is returned.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>number</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="global.html#number">number</a></span>
|

<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">Number to format.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fractionSize</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="global.html#number">number</a></span>
|

<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Number of decimal places to round the number to.
If this is not provided then the fraction size is computed from the current locale's number
formatting pattern. In the case of the default locale, it will be 3.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14211">line 14211</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Number rounded to decimalPlaces and places a “,” after each third digit.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

        

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script>
      function Ctrl($scope) {
        $scope.val = 1234.56789;
      }
    &lt;/script>
    &lt;div ng-controller="Ctrl">
      Enter number: &lt;input ng-model='val'>&lt;br>
      Default formatting: &lt;span id='number-default'>{{val | number}}&lt;/span>&lt;br>
      No fractions: &lt;span>{{val | number:0}}&lt;/span>&lt;br>
      Negative number: &lt;span>{{-val | number:4}}&lt;/span>
    &lt;/div>
  &lt;/file>
  &lt;file name="protractor.js" type="protractor">
    it('should format numbers', function() {
      expect(element(by.id('number-default')).getText()).toBe('1,234.568');
      expect(element(by.binding('val | number:0')).getText()).toBe('1,235');
      expect(element(by.binding('-val | number:4')).getText()).toBe('-1,234.5679');
    });

    it('should update', function() {
      element(by.model('val')).clear();
      element(by.model('val')).sendKeys('3374.333');
      expect(element(by.id('number-default')).getText()).toBe('3,374.333');
      expect(element(by.binding('val | number:0')).getText()).toBe('3,374');
      expect(element(by.binding('-val | number:4')).getText()).toBe('-3,374.3330');
   });
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="orderBy"><span class="type-signature"></span>orderBy<span class="signature">(array, expression, <span class="optional">reverse</span>)</span><span class="type-signature"> &rarr; {Array}</span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Orders a specified `array` by the `expression` predicate.
    </div>
    

    

    

    
        <h5>Parameters:</h5>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>array</code></td>
            

            <td class="type">
            
                
<span class="param-type">Array</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">The array to sort.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>expression</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>
|

<span class="param-type">string</span>
|

<span class="param-type">Array.&lt;(function(*)|string)></span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last">A predicate to be
   used by the comparator to determine the order of elements.

   Can be one of:

   - `function`: Getter function. The result of this function will be sorted using the
     `<`, `=`, `>` operator.
   - `string`: An Angular expression which evaluates to an object to order by, such as 'name'
     to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control
     ascending or descending sort order (for example, +name or -name).
   - `Array`: An array of function or string predicates. The first predicate in the array
     is used for sorting, but when two items are equivalent, the next predicate is used.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reverse</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">Reverse the order the array.</td>
        </tr>

    
    </tbody>
</table>
    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14745">line 14745</a>
    </li></ul></dd>
    

    

    

    
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    Sorted copy of the source array.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Array</span>


    </dd>
</dl>

        

    
        <h5>Example</h5>
        
    <pre class="prettyprint"><code>&lt;example>
  &lt;file name="index.html">
    &lt;script>
      function Ctrl($scope) {
        $scope.friends =
            [{name:'John', phone:'555-1212', age:10},
             {name:'Mary', phone:'555-9876', age:19},
             {name:'Mike', phone:'555-4321', age:21},
             {name:'Adam', phone:'555-5678', age:35},
             {name:'Julie', phone:'555-8765', age:29}]
        $scope.predicate = '-age';
      }
    &lt;/script>
    &lt;div ng-controller="Ctrl">
      &lt;pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}&lt;/pre>
      &lt;hr/>
      [ &lt;a href="" ng-click="predicate=''">unsorted&lt;/a> ]
      &lt;table class="friend">
        &lt;tr>
          &lt;th>&lt;a href="" ng-click="predicate = 'name'; reverse=false">Name&lt;/a>
              (&lt;a href="" ng-click="predicate = '-name'; reverse=false">^&lt;/a>)&lt;/th>
          &lt;th>&lt;a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number&lt;/a>&lt;/th>
          &lt;th>&lt;a href="" ng-click="predicate = 'age'; reverse=!reverse">Age&lt;/a>&lt;/th>
        &lt;/tr>
        &lt;tr ng-repeat="friend in friends | orderBy:predicate:reverse">
          &lt;td>{{friend.name}}&lt;/td>
          &lt;td>{{friend.phone}}&lt;/td>
          &lt;td>{{friend.age}}&lt;/td>
        &lt;/tr>
      &lt;/table>
    &lt;/div>
  &lt;/file>
&lt;/example></code></pre>

    
</dd>

        
            
<dt>
    <h4 class="name" id="uppercase"><span class="type-signature"></span>uppercase<span class="signature">()</span><span class="type-signature"></span></h4>

    
</dt>
<dd>

    
    <div class="description">
        Converts string to uppercase.
    </div>
    

    

    

    

    
<dl class="details">
    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="angular.js.html">angular.js</a>, <a href="angular.js.html#line14626">line 14626</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li>angular.uppercase</li>
        </ul>
    </dd>
    

    
</dl>


    

    

    

    

    

    

    
</dd>

        </dl>
    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-ng.html">ng</a></li></ul><h3>Classes</h3><ul><li><a href="module-ng-Lexer.html#text">text</a></li><li><a href="module-ng-Lexer_tokens.html">tokens</a></li><li><a href="module-ng-Parser_tokens.html">tokens</a></li><li><a href="module-ng-token.text.html">text</a></li></ul><h3>Global</h3><ul><li><a href="global.html#$anchorScroll">$anchorScroll</a></li><li><a href="global.html#$animate">$animate</a></li><li><a href="global.html#$animateProvider">$animateProvider</a></li><li><a href="global.html#$browser">$browser</a></li><li><a href="global.html#$cacheFactory">$cacheFactory</a></li><li><a href="global.html#$compile">$compile</a></li><li><a href="global.html#$compileProvider">$compileProvider</a></li><li><a href="global.html#$controller">$controller</a></li><li><a href="global.html#$controllerProvider">$controllerProvider</a></li><li><a href="global.html#$document">$document</a></li><li><a href="global.html#$exceptionHandler">$exceptionHandler</a></li><li><a href="global.html#$filter">$filter</a></li><li><a href="global.html#$filterProvider">$filterProvider</a></li><li><a href="global.html#$http">$http</a></li><li><a href="global.html#$httpBackend">$httpBackend</a></li><li><a href="global.html#$injector">$injector</a></li><li><a href="global.html#$interpolate">$interpolate</a></li><li><a href="global.html#$interpolateProvider">$interpolateProvider</a></li><li><a href="global.html#$interval">$interval</a></li><li><a href="global.html#$locale">$locale</a></li><li><a href="global.html#$location">$location</a></li><li><a href="global.html#$locationProvider">$locationProvider</a></li><li><a href="global.html#$log">$log</a></li><li><a href="global.html#$logProvider">$logProvider</a></li><li><a href="global.html#$parse">$parse</a></li><li><a href="global.html#$parseProvider">$parseProvider</a></li><li><a href="global.html#$provide">$provide</a></li><li><a href="global.html#$q">$q</a></li><li><a href="global.html#$rootScope">$rootScope</a></li><li><a href="global.html#$rootScopeProvider">$rootScopeProvider</a></li><li><a href="global.html#$sce">$sce</a></li><li><a href="global.html#$sceDelegate">$sceDelegate</a></li><li><a href="global.html#$sceDelegateProvider">$sceDelegateProvider</a></li><li><a href="global.html#$sceProvider">$sceProvider</a></li><li><a href="global.html#$sniffer">$sniffer</a></li><li><a href="global.html#$templateCache">$templateCache</a></li><li><a href="global.html#$timeout">$timeout</a></li><li><a href="global.html#$window">$window</a></li><li><a href="global.html#a">a</a></li><li><a href="global.html#angular">angular</a></li><li><a href="global.html#auto">auto</a></li><li><a href="global.html#currency">currency</a></li><li><a href="global.html#date">date</a></li><li><a href="global.html#filter">filter</a></li><li><a href="global.html#form">form</a></li><li><a href="global.html#input">input</a></li><li><a href="global.html#input[checkbox]">input[checkbox]</a></li><li><a href="global.html#input[email]">input[email]</a></li><li><a href="global.html#input[number]">input[number]</a></li><li><a href="global.html#input[radio]">input[radio]</a></li><li><a href="global.html#input[text]">input[text]</a></li><li><a href="global.html#input[url]">input[url]</a></li><li><a href="global.html#json">json</a></li><li><a href="global.html#limitTo">limitTo</a></li><li><a href="global.html#lowercase">lowercase</a></li><li><a href="global.html#ng">ng</a></li><li><a href="global.html#ngBind">ngBind</a></li><li><a href="global.html#ngBindHtml">ngBindHtml</a></li><li><a href="global.html#ngBindTemplate">ngBindTemplate</a></li><li><a href="global.html#ngChange">ngChange</a></li><li><a href="global.html#ngChecked">ngChecked</a></li><li><a href="global.html#ngClass">ngClass</a></li><li><a href="global.html#ngClassEven">ngClassEven</a></li><li><a href="global.html#ngClassOdd">ngClassOdd</a></li><li><a href="global.html#ngClick">ngClick</a></li><li><a href="global.html#ngCloak">ngCloak</a></li><li><a href="global.html#ngController">ngController</a></li><li><a href="global.html#ngCopy">ngCopy</a></li><li><a href="global.html#ngCsp">ngCsp</a></li><li><a href="global.html#ngCut">ngCut</a></li><li><a href="global.html#ngDblclick">ngDblclick</a></li><li><a href="global.html#ngDisabled">ngDisabled</a></li><li><a href="global.html#ngFocus">ngFocus</a></li><li><a href="global.html#ngForm">ngForm</a></li><li><a href="global.html#ngHide">ngHide</a></li><li><a href="global.html#ngHref">ngHref</a></li><li><a href="global.html#ngIf">ngIf</a></li><li><a href="global.html#ngInclude">ngInclude</a></li><li><a href="global.html#ngInit">ngInit</a></li><li><a href="global.html#ngKeydown">ngKeydown</a></li><li><a href="global.html#ngKeypress">ngKeypress</a></li><li><a href="global.html#ngKeyup">ngKeyup</a></li><li><a href="global.html#ngList">ngList</a></li><li><a href="global.html#ngModel">ngModel</a></li><li><a href="global.html#ngMousedown">ngMousedown</a></li><li><a href="global.html#ngMouseenter">ngMouseenter</a></li><li><a href="global.html#ngMouseleave">ngMouseleave</a></li><li><a href="global.html#ngMouseover">ngMouseover</a></li><li><a href="global.html#ngMouseup">ngMouseup</a></li><li><a href="global.html#ngNonBindable">ngNonBindable</a></li><li><a href="global.html#ngOpen">ngOpen</a></li><li><a href="global.html#ngPaste">ngPaste</a></li><li><a href="global.html#ngPluralize">ngPluralize</a></li><li><a href="global.html#ngReadonly">ngReadonly</a></li><li><a href="global.html#ngRepeat">ngRepeat</a></li><li><a href="global.html#ngSelected">ngSelected</a></li><li><a href="global.html#ngShow">ngShow</a></li><li><a href="global.html#ngSrc">ngSrc</a></li><li><a href="global.html#ngSrcset">ngSrcset</a></li><li><a href="global.html#ngStyle">ngStyle</a></li><li><a href="global.html#ngSubmit">ngSubmit</a></li><li><a href="global.html#ngSwitch">ngSwitch</a></li><li><a href="global.html#ngTransclude">ngTransclude</a></li><li><a href="global.html#ngValue">ngValue</a></li><li><a href="global.html#number">number</a></li><li><a href="global.html#orderBy">orderBy</a></li><li><a href="global.html#script">script</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#textarea">textarea</a></li><li><a href="global.html#uppercase">uppercase</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Mon Mar 24 2014 20:50:52 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>